Процесс _обработки исключений_ (exception handling) состоит из нескольких шагов. Сначала нужно определить, что именно считать ошибкой. Затем нужно выяснить, как возникает ошибка и как от неё избавиться. Скорее всего, в момент ошибки код находится в каком-то промежуточном состоянии, и его потребуется вернуть в состояние до момента возникновения ошибки.

## Определение "исключения"

Конструируя тип, разработчики заранее пытаются представить, в каких ситуациях тип будет использоваться. Члены типа определяют допустимые действия с типом и его экземплярами. Если член не может решить поставленную перед ним задачу, он должен выбросить исключение. Не все члены типа умеют возвращать код ошибки, но они должны каким-то образом сообщать о её наличии. В .NET и всех поддерживаемых этой платформой языках существует специальный механизм обработки исключений.

## Механика обработки исключений

В основе обработки исключений в .NET лежит _структурная обработка исключений_ (Structured Exception Handling, SEH).

```csharp
private void SomeMethod()
{
  try
  {
    // Код, требующий корректного восстановления или очистки ресурсов
  }
  catch (InvalidOperationException)
  {
    // Код восстановления работоспособности после исключения InvalidOperationException
  }
  catch (IOException)
  {
   // Код восстановления работоспособности после исключения IOException
  }
  catch
  {
    // Код восстановления работоспособности после остальных исключений.
    // После перехвата исключений их обычно генерируют повторно
    throw;
  }
  finally
  {
    // Здесь находится код, выполняющий очистку ресурсов после операций, начатых в блоке try.
    // Этот код выполняется ВСЕГДА вне зависимости от наличия исключения
  }

  // Код, следующий за блоком finally, выполняется, если в блоке try не генерировалось исключение
  // или если исключение было перехвачено блоком catch, а новое не генерировалось
}
```

В большинстве случаев используются комбинации `try-catch` или `try-finally`.

### Блок try 

В данный блок помещается код, требующий очистки ресурсов (прим. Комбинацией `try-finally` можно заменить ключевое слово `using`) и/или восстановления после исключения. Код очистки содержится в блоке `finally`. Также в блоке `try` может располагаться код, приводящий к генерации исключения. Код восстановления вставляют в один или несколько блоков `catch`. Блок `try` не может определяться сам по себе, так как это не имеет смысла, и C# запрещает такие определения. 

Внутри блока `try` следует размещать ровно столько кода, сколько можно обработать одним блоком `catch`. Если же в `try` генерируется одно и то же исключение для разных строчек, но обрабатывать их необходимо по-разному, то стоит разделить данный блок на блоки поменьше.

### Блок catch 

В данный блок помещают код, который должен выполняться в ответ на исключение, если же исключение не возникло, то код в данном блоке не будет вызван.

Выражение в скобках после ключевого слова `catch` называется _типом исключения_ (catch type). В C# эту роль играет тип `System.Exception` и его производные. Если тип исключения не указывается, то отлавливаются все типы исключений, однако информация о них не доступна.

Поиск подходящего блока `catch` в CLR осуществляется сверху вниз, поэтому наиболее конкретные обработчики должны находиться в начале списка. В противном случае компилятор сообщит об ошибке, так как менее онкретные обработчики окажутся недоступны.

Исключение, сгенерированное при выполнении блока `try`, ининцирует поиск блоков `catch` соответствующего типа, а при их отсутствии - просматривается стек вызовов. Если по достижении верщины стека блок нужного типа не найден, то выбрасывается необработанное исключение. 

В блоке `catch` выбирается способ восстановления после исключения из трёх вариантов:
- Ещё раз сгенерировать то же исключение для передачи его выше по стеку.
- Сгенерировать исключение другого типа для передачи дополнительной информации выше по стеку.
- Позволить программному потоку выйти из данного блока естественным образом.

В первых двух случаях происходит просмотр выше по стеку в поисках блока `catch` нужного типа. В третьем случае происходит переход к блоку `finally`. Если этот блок отсутствует, то выполняется следующий после `catch` код. 

### Блок finally 

Код блока `finally` выполняется всегда, кроме случаев, когда поток прерывается функцией `TerminateThread()` или методом `System.Environment.FailFast()`. Обычно этот блок производит очистку после выполнения блока `try`. Если же поместить очистку в код после `finally`, то она может не выполниться в случае необработанного исключения. Код блоков `catch` и `finally` должны быть максимально короткими и работающими без исключений. Если же в данных блоках возникают исключения, это может свидетельствовать о наличии серьёзных ошибок (скорее всего, о повреждении текущего состояния). Данное исключение не должно обрабатываться, так как оно уничтожает повреждённое состояние. В противном случае это может привести к непредсказуемым результатам и появлению дефектов в системе безопасности.   

### CLS-совместимые и CLS-несовместимые исключения

Все языки, ориентированные на CLR должны поддерживать создание объектов класса `Exception`, так как этого требует CLS. Однако в CLR можно создавать исключения любых типов, хотя компилятор C# не разрешает генерировать их. 

До выхода верси CLR 2.0 в блоках `catch` перехватывались только CLS-совместимые исключения. Если же метод на C# вызывал метод, написанный на другом языке, и тот генерировал CLS-несовместимое исключение, то его невозможно было отловить, что было чревато нарушением защиты. 

Начиная с CLR 2.0 появился класс `System.Runtime.CompilerServices.RuntimeWrappedException`, который является производным от `Exception` и CLS-совместимым. При генериции CLS-несовместимого исключения автоматически создавался кземпляр данного класса, закрытому полю которого присваивалась ссылка на выброшенный объект. Таким образом исключение становилось CLS-совместимым. До версии 2., перехват исключений проиходил примерно так:

```csharp 
private void SomeMethod()
{
  try
  {
    // Внутрь блока try помещают код, требующий корректного восстановления работоспособности или очистки ресурсов
  }
  catch (Exception e)
  {
    // До C# 2.0 этот блок перехватывал только CLS-совместимые исключения
    // В C# 2.0 этот блок научился перехватывать также CLS-несовместимые исключения
    throw; // Повторная генерация перехваченного исключения
  }
  catch
  {
    // Во всех версиях C# этот блок перехватывает и совместимые, и несовместимые с CLS исключения
    throw; // Повторная генерация перехваченного исключения
  }
}
```

Если этот код перекомпилировать для CLR 2.0, последний блок `catch` никогда не будет выполняться. Для решения этой проблемы есть два способа: можно объединить последние блоки `catch` в один или можно сообщить CLR, чтобы обработка исключений работала по старым правилам (для этого сборка помечается специальным атрибутом).

## Класс System.Exception 

System.Exception - очень простой тип с небольшим набором свойств, которые используются при отладке. Среди них есть сообщение с текстом описания причины ошибки, имя сгенерировавшей исключение сборки, стек трейс (имена и сигнатуры методов, вызов которых стал источником исключения), имя вызвашего исключение метода, адрес докуменатции и исключение, в ходе обработки которого было выброшено текущее.

Информация в `StackTrace` может быть крайне полезной дляпоиска объекта, ставшего источником исключения, и последующего исправления кода. При обращении к этому свойству фактически происходит обращение к коду в CLR, потому что свойство не просто возвращает строку. При создании объекта типа, производного от `Exception`, данному свойству присваивается `null`. При появлении исключения CLR делает запись с указанием места его возникновения. И если в блоке `catch` обратиться к свойсвту `StackTrace`, то код обратится к CLR, где и будет указана строка, содержащая имена всех методов от точки, где оно было выброшено, до точки, где оно было перехвачено. При появлении исключения CLR обнуляет его началную точку. Однако если в блоке `catch` написать `throw;` без указания исключения, то обнуление информации о стеке не производится.

```csharp 
private void SomeMethod() {
  try { ... }
  catch (Exception e)
  {
    ...
    throw e; // CLR считает, что исключение возникло тут
             // FxCop сообщает об ошибке
  }
  
  try { ... }
  catch (Exception e)
  {
    ...
    throw; // CLR не меняет информацию о начальной точке исключения.
           // FxCop НЕ сообщает об ошибке
  }
}
```

В случае возникновения необработанного исключения в систему сбора информации об ошибках уходят сведения о последнем выброшенном исклчении, что может серьёзно усложнить оладку. Некоторые разработчики для обхода этого ограничения применяют некоторый костыль:

```csharp  
private void SomeMethod()
{
  Boolean trySucceeds = false;

  try
  {
    ...
    trySucceeds = true;
  }
  finally
  {
    if (!trySucceeds) { /* код перехвата исключения */ }
  }
}
```

Так как `StackTrace` не включает в себя имена методов, расположенных в стеке вызова выше точки принятия исключения блоком `catch`. Для отслеживания всего стека используется тип `System.Diagnostics.StackTrace`.

Если CLR обнаруживает для сборок символические имена отладки, то стек трэйс содержит пути файлов исходного кода и номера строк. Эта информация может быть полезна для отладки.

## Классы исключений, определённые в FCL 

Описывается иерархия классов исключений. Подробнее в книге.

## Генерирование исключений

При реализации своего метода слеует генерировать исключение, если метод не в состоянии выполнить поставленную задачу. При этом необходимо учитывать два фактора:
1. Стоит очень осмотрительно выбирать производный от `System.Exception` тип, чтобы он как можно более полно описывал возникшую проблему и чтобы вызывающий метод мог более точно выполнить восстановительные работы. Если необходимого типа нет в FCL или дополнительных библиотеках, стоит определить новый тип. Если при написании класса исключения создаётся иерархия, то стоит подумать над тем, чтобы в ней было как можно меньше базовых классов, потому что в таком случае будет меньше возможностей указать в блоке `catch` базовый класс и описать более точное восстановительное поведение. 
2.  Следует максимально полно описывать причину ошибки в тексте сообщения об ошибке исключения. Эту инфомрацию можно свободно писать в логи, так как у пользователей нет доступа к этим данных, а разработчикам будет проще исправлять ошибки, возникшие во время выполнения, а не отладки

## Создание классов исключений

Описывается создание классов исключений. Подробнее в книге.

## Продуктивность вместо надёжности

Продуктивность разработки достигается не только за счёт композиционности кода, но и благодаря некоторым возмоностям компиляторов, среди которых неявные:
- Вставка в вызываемый метод необязательных параметров.
- Упаковка экземпляров значимого типа.
- Создание и инициализация массивов параметров.
- Связывание с членами динамических и переменных выражений.
- 

## Приёмы работы с исключениями 



### Активно используйте блоки finally



### Не надо перехватывать все исключения



### Корректное восстановление после исключения



### Отмена незавершённых операций при невосстановимых исключениях 



### Сокрытие деталей реализации для сохранения контракта



## Необработанные исключения



## Отладка исключений



## Скорость обработки исключений



## Области ограниченного выполненния



## Контракты кода

