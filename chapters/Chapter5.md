## Примитивные типы в языках программирования

Типы данных, которые поддержиаются компилятором напрямую, называются _примитивными_ (primitive types); у них существуют прямые аналоги в .NET FCL. Ниже представлены типы FCL и соответствующие им примитивные типы C#. В других языка типам, удовлетворяющим CLS, соответствуют аналогичные примитивные типы. 

| Примитивный тип | FCL-тип        | Совместимость с CLS | Описание                                                                                                               |
| :-------------: | :------------: | :-----------------: | :--------------------------------------------------------------------------------------------------------------------- |
| sbyte           | System.Sbyte   | Нет                 | 8-разрядное значение со знаком                                                                                         |
| byte            | System.Byte    | Да                  | 8-разрядное значение без знака                                                                                         |
| short           | System.Int16   | Да                  | 16-разрядное значение со знаком                                                                                        |
| ushort          | System.Uint16  | Нет                 | 16-разрядное значение без знака                                                                                        |
| int             | System.Int32   | Да                  | 32-разрядное значение со знаком                                                                                        |
| uint            | System.Unit32  | Нет                 | 32-разрядное значение без знака                                                                                        |
| long            | System.Int64   | Да                  | 64-разрядное значение со знаком                                                                                        |
| ulong           | System.Uint64  | Нет                 | 64-разрядное значение без знака                                                                                        |
| char            | System.Char    | Да                  | 16-разрядный символ Unicode                                                                                            |
| float           | System.Single  | Да                  | 32-разрядное значение с плавающей точкой                                                                               |
| double          | System.Double  | Да                  | 64-разрядное значение с плавающей точкой                                                                               |
| bool            | System.Boolean | Да                  | Булево значение                                                                                                        |
| decimal         | System.Decimal | Да                  | 128-разрядное значение с плавающей точкой повышенной точности (часто используется для выполнения финансовых операций)  |
| string          | System.String  | Да                  | Массив символов                                                                                                        |
| object          | System.Sbyte   | Да                  | Базовый тип для всех типов                                                                                             |
| dynamic         | System.Sbyte   | Да                  | Для CLR идентичен типу object (при этом позволяет участвовать в динамическом разрешении типа с упрощённым синтаксисом) |

Иначе говоря, можно считать, что компилятор C# автоматически предполагает, что во всех файла подключены дипрективы вида `using <primitive type> = <FCL-type>;`.

Спецификация языка C# советует использовать ключевое слово, а не полное имя типа. Однако Джеффри Рихтер с этим не согласен по следующим причинам:
- Некоторые разработчики, используя ключевые слова, совершенно не понимаю, что за ними прячется: некоторые считают, что `int` представляет 32-разрядное число в 32-разрядной системе и 64-разрядное в 64-разрядной, что в корне неверно, так как `int` всегда представляет `System.Int32`.
- В C# `long` представляет `System.Int64`, однако в других языках оно может обозначать другой тип (например, в C++/CLI оно трактуется как Int32). Это может привести к путанице в попытках прочитать код на новом языке.
- У многих FCL типов есть методы, которые включают в себя имена типов. Из-за этого может возникать путаница, например, в методе `float val = bt.ReadSingle();`.

Компилятор умеет выполнять явное и неявное приведение между примитивными типами. Неявное применяется от менее разрядных типов к более (если приведение безопасно: не сопряжено с потерей данных), а явное - наоборот.

Помимо приведения, компилятор знает и о литеральной форме записи примитивных типов (дитералы считаются экземплярами типов, поэтому к ним спокойно можно применять методы `123.ToString();`).

Кроме этого, выражения, состоящие из литералов, вычисляют на этапе компиляции, что повышает скорость выполнения приложения. 

Наконец, компилятор знает, в каком порядке интерпретировать все встречающиеся в коде операторы.

### Проверяемые и непроверяемые операции для примитивных типов

Существует такое явление как переполнение, когда значение становится больше, чем допустимо для данного типа. и тогда старшие байты отбрасываются. Переполнение обычно не приветствуется, однако иногда (при вычислении хешей или контрольных сумм) может быть даже полезно.

```csharp
Byte b = 100;
b = (Byte) (b + 200);
```

При выполнении этой операции все значения операндов расширяются до 32 разрядов (или 64, если 32 недостаточно). Полученное 32-разрядное число помещается в переменную типа Byte, где и происходит переполнение и отсечение.

В каждом языке существуют свои правила обработки переполнения: какой-то язык может его игнорировать, а какой-то - вызывать исключения. В CLR для этого есть отдельные команды (add и add.ovf). Подобные команды есть для вычитания (sub/sub.ovf), умножения (mul/mul.ovf) и преобразования данных (conv/conv.ovf). 

По умолчанию команды с проверкой переполнения выключены и программист должен это предусмотреть при написании приложения. Включить проверку можно с использованием параметры `/checked+` у компилятора, что замедлит выполнение программы. Однако, в этом случае стоит подумать об обработке выкидываемого искючения. 

Но программистам вряд ли понравится необходимость включения или выключения этой возможности на этапе компиляции, поэтому в C# для этого придуман механизм гибкого управления проверки переполнения виде операторов `checked` и `unchecked`. Наряду с этими операторами в C# есть одноимённые инструкции, которые проверяют не операцию, а блок кода в фигурных скобках.

При использовании этих операторов стоит соблюдать некоторые правила:
- Использовать целочисленные типы со знаком, что позволит компилятору выявлять ошибку переполнения. Кроме того, некоторые компоненты библиотеки классов возвращают значения со знаком, и передача этих значений потребует меньшего количества преобразований типа.
- Включать в блок `checked` любой код, в котором возможно переполнение (например, при вводе пользовательских данных), а затем обрабатывать исключение.
- Включать в блок `unchecked` код, в котором переполнение не создаёт проблем.
- В коде, где нет этих операторов или блоков, предполагается, что при переполнении должно происходить исключение.

Тип System.Decimal стоит особняком, так как в CLR он не относится к примитивным типам. Все математические опреации описаны статическими методами и перегруженными операторами. Это означает, что в IL нет определённых команд для манипуляции числами, а значит, здесь не имеют эффекта операторы `checked` и `uncheked`.  

## Ссылочные и значимые типы

CLR поддерживает две разновидности типов: _ссылочные_ (reference types) и _значимые_ (value types). Большинство типов в FCL - ссылочные, но разработчики чаще всего используют значимые. Память для ссылочных типов выделяется  из управляемой кучи, а оператор `new()` возвращает адрес в памяти. При работы со ссылочными типами следует учитывать следующие обстоятельста:
- Память всегда выделяется из упраляемой кучи.
- Каждый объект, размещённый в куче, содержит дополнительные члены, подлежающие инициализации.
- Незанятые полезной иныормацией байты объекта обнуляются (это касается полей). Размещение объекта в управляемой куче со временем инициирует сьорку мусора.

Если бы все типы были ссылочными, эффективность приожения бы резко упала из-за постоянного выделения и очищения памяти в куче. Поэтому для ускорения обработки простых, часто используемых типов CLR предлагает облегчённые типы - _значимые_. Экземпляры этих типов обычно размещаются в стеке (хотя могут быть встроены и в объект ссылочного типа). В представляющей экземпляр переменной нет указателя на экземпляр, поля размещаются в самой переменной, поэтому не нужно выполнять [разыменование (dereference)](https://ru.wiktionary.org/wiki/разыменование). Благодаря тому, что экземпляры значимых типо не обрабатываются сборщиком мусора, уменьшается интенсивность работы с управляемой кучей и сокращается количество сборок. 

В .NET Framework ссылочные типы называют _классами_ (class), а значимые - _структурами_ (struct) и _перечислениями_ (enumeraton). Все структуры являются потомками абстрактного типа `System.ValueType` (по умолчанию все значимые типы должны быть производными от него), а он является производным от `System.Object`.  Все перечисления являются производными от типа `System.Enum`, а он является производным от `System.ValueType`. 

При определение собственного значимого типа нельзя выбрать произвольный базовый тип, но он может реализовывать один или несколько интерфейсов. Кроме того, в CLR значимый тип является изолированным, то есть он не может являться базоывым типом.

В управляемом коде раработчик, описывающий тип, решает, где будет размещаться экземляр этого типа, а разработчик, использующий этот тип, управлять этим не может.

В коде и на рисунке ниже описывается различие между ссылочными и значимыми типами.

```csharp
// Ссылочный тип (поскольку 'class')
class SomeRef { public Int32 x; }

// Значимый тип (поскольку 'struct')
struct SomeVal { public Int32 x; }

static void ValueTypeDemo() {
    SomeRef r1 = new SomeRef(); // Размещается в куче
    SomeVal v1 = new SomeVal(); // Размещается в стеке

    r1.x = 5; // Разыменовывание указателя
    v1.x = 5; // Изменение в стеке

    Console.WriteLine(r1.x); // Отображается "5"
    Console.WriteLine(v1.x); // Также отображается "5"

    SomeRef r2 = r1; // Копируется только ссылка (указатель)
    SomeVal v2 = v1; // Помещаем в стек и копируем члены

    r1.x = 8; // Изменяются r1.x и r2.x
    v1.x = 9; // Изменяется v1.x, но не v2.x

    Console.WriteLine(r1.x); // Отображается "8"
    Console.WriteLine(r2.x); // Отображается "8"
    Console.WriteLine(v1.x); // Отображается "9"
    Console.WriteLine(v2.x); // Отображается "5"
}
```

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/1d508b4f-6425-4d8d-9af6-8cb226743976)

При проектировании типов стоит проверить, не использовать ли вместо ссылочного типа значимый, так как иногда это может повысить эффективность кода. Сказанное справедливо для типов, удовлетворяющих всем условиям:
- Тип ведёт себя подобно примитивному типу. Это означает, что тип достаточно простой и у него нет членов, способных изменить экземплярное состояние. В это случае говорят, что тип _неизменяемый_(immutable).
- Тип не обязан иметь любой другой тип в качестве базового.
- Тип не имеет производных от него типов.

Также необходимо учитывать размер экземпляров типа, потому что по умолчанию аргументы передаются по значению; при этом поля экземпляров значимого типа копируются, что негативно сказывается на производительности. Поэтому дополнительно необходимо, чтобы выполнялось хотя бы одно из условий:
- Размер экземпляров типа мал (примерно 16 байт или меньше).
- Размер экземпляров типа велик (более 16 байт), но экземпляры не передаются в качестве аргументов метода и не являются возвращаемыми из метода значениями.

Основные отличия между ссылочными и значимыми типами:
- Объекты значимого типа могут быть _упакованными_ (boxed) и _неупакованными_ (unboxed). Ссылочные типы существут только в упакованной форме.
- Значимые типы являются наследниками `System.ValueType`. Этот тип имеет все те же методы, что и `System.Object`, однако он переопределяет методы `Equals()`, чтобы тот сравнивал экземпляры по значениям, а также метод `GetHashCode()`, в котором алгоритм учитываются значения. Однако, из-за пробелм с производительность стоит переопределять эти методы самому при написании значимых типов.
- Поскольку нельзя наследоваться от значимого типа, то он не может быть абстрактным (является неявно запечатанным) и не может содержать виртуальных методов.
- Так как значимый тип не указывает на объект в куче, то он не может быть `null` (за исключением `nullable` типов), соответственно, нельзя получить `NullReferenceException`.
- При присваивании одной переменной значимого типа другой переменной происходит копирование всех полей. При присваивании переменной ссылочного типа - копируется адрес.
- Всоедствие предыдущего пункта несколько переменных ссылочного типа могут ссылаться на один объект в куче и изменения в одной переменной порождают изменения во всех остальных. Переменные значимого типа изолированны друг от друга.
- Так как неупакованные значимые типы не размещаются в куче, то и занятая ими память освобождается сразу при возвращении стека к предыдущему кадру, не дожидаясь сборки мусора.

### Как CLR управляет размещением полей для типа

Для повышения производительности CLR дано право устанавливать порядок размещения полей типа. Например, среда может вытроить поля таким образом, что ссылки на объекты окажутся в одной группе, а поля данных и свойства - выровненные и упакованные - в другой. Однако при описании типа можно указать, сохранить ли порядок полей.

По умолчанию, поля ссылочных типов размещаются в памяти сгруппировано, а значимых - последовательности, так, как определил разработчик. Это можно изменить с помощью специальных атрибутов.

## Упаковка и распаковка значимых типов



### Изменение полей в упакованных типах посредством интерфейсов (и почему этого лучше не делать)



### РАвенство и тождество объектов



## Хеш-коды объектов



## Примитивный тип данных dynamic

