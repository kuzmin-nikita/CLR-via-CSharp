## Пул потоков в CLR 

CLR способна управлять собственным пулом потоков, то есть набором готовых потоков, доступных для использования приложениями. Для каждого эземпляра CLR существует свой пул, используемый всеми доменами.

При инициализации CLR пул потоков пуст. Для выполнения прилоением асинхронной оперции вызывается метод, размещающий соответстующий зарпос в очереди пула потоков. Код пула извлекает записи из очереди и распределяет и среди потоков пула. Если пул пуст, создаётся новый поток. По завершении задания поток не уничтожается, а возвращается в пул. Благодаря этому производительность не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их все в одном потоке. Однако если приложение создаёт очередь запросов быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки. Такой подход позволяет обойтись небольшим числом потоков.

Когда приложение прекращает отпраывлять запросы в пул, появляются незанятые потоки. Через некоторое время бездействия поток пробуждается и уничтожается, освобождая ресурсы.

Пул потоков позволяет найти компромисс в ситуации, когда малое количество потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами многопроцессорных систем, а также многоядерных и гиперпоптоковых процессоров.

## Простые вычислительные операции

В разделе описываеся добавление асинхронных вычислительных операций в очередь пула потоков с помощью метода `ThreadPool.QueueUserWorkItem()`.

## Контексты исполнения

С каждым потоком связан определённый контекст исполнения, который включает в себя параметры безопасности, параметры хотса и контекстные данные логического вызова.

По умолчанию CLR автоматически копирует контекст исполнения саммого первого потока во все вспомогательные потоки. Это гарантирует безопасность, но в ущерб производительости. С помощью класса `System.Threading.ExecutionContext` можно запретить копирование контекста, что может сильно повычить быстродействие серверных приложений.

## Скоординированная отмена

.NET предлагает стандартный паттерн операций отмены. Этот паттерн является _скоординированным_ (cooperative), то есть требует явной поддержки отмены операций. В состав стандартного паттерна скоординированной отмены входят два типа из FCL: `CancellationTokenSource` (ссылочный тип) и `CancellationToken` (значимый тип). После создания `CancellationTokenSource` можно получить один или несколько экземпляров `CancellationToken`. Затем они передаются операциям, поддерживающим отмену.

Экземпляр `CancellationToken` относится к упрощённому типу, так как содержит одно закрытое поле: ссылку на свой объект `CancellationTokenSource`. Цикл вычислительной операции может периодически обращаться к своейству `CancellationToken.IsCancellationRequested`, чтобы узнать, не требуется ли прерывание операции. Тогда процессор перестаёт совершать операции.

## Задания

Самой большой проблемой при вызове метода `ThreadPool.QueueUserWorkItem()` явялется отсустствие временного механизма, позволяющего узнать о завершении операции и получить возвращаемое значение. Для обхода этих и других ограничений было введено понятие _заданий_ (tasks), выполнение которых выполняется посредством типов из пространства имён `System.Threading.Tasks`.

### Завершение задания и получение результата

Можно дождаться завершения задания в явном виде с помощью экземплярного метода `Task.Wait()` и после этого получить результат его выполнения. Для этого можно создать объект типа `Task<TResult>`, передав в качестве аргумента-типа возвращаемый задачей тип.

При вызове потоком метода `Wait()`, система проверяет, началось ли выполнение задания, которого ожидает поток. Если да, то поток блокируется до завершения задачи. Но если выполнение ещё не началось, то система может выполнить его при помощи потока, вызывающего метод `Wait()`. В этом случае поток не блокируется. Он выполняет задание и возвращает управление. Это снижает затраты, так как не приходится создавать поток взамен заблокированного, и повышает производительность, так как на создание потока и переключение контекста не тратится время. Однако если перед вызовом `Wait()` поток блокируется в рамках синхронизации, то возникает взаимная блокировка (deadlock).

Если задание генерирует исключение, то оно поглощается и сохраняется в коллекции, а поток возвращается в пул. Затем при вызове метода `Wait()` или свойства `Result` эти члены выбросят исключение [AggregateException](https://learn.microsoft.com/en-us/dotnet/api/system.aggregateexception?view=net-8.0). 

Можо дожидаться завершения не только одного задания, но и массива объектов этого типа. Для этого есть два статических метода `WaitAny()` и `WaitAll()`.

### Отмена задания

Для отмены задания можно воспользоваться объектом `CancellationTokenSource`, для этого в метод неободимо добавить генерацию исключения, если задача отменена. Исключение генерируется как сигнал того, завершена ли задача.

### Автоматический запуск задания по завершении предыдущего

Для написания масштабируемого ПО стоит избегать блокировки потоков. Вызов метода `Wait()` или свойства `Result` при незавершённом задании пиведёт, скорее всего, к появлению в пуле нового потока, то увеличит расход ресурсов и негативно скажется на расширяемости. Для того, чтобы избежать блокирования потоков, стоит инициировать следующее задание по выполнению предыдущего с помощью методы `ContinueWith()`. Исполняющий такой код поток не блокируется, ожидая завершения заданий; в это время он может исполнять какой-то другой код или, если это поток из пула, вернуться в пул для решения других задач.

### Дочерние задания

Задания поддеживают отношения предок-потомок. Родительское задание выполняется после того, как будут завершены все дочерние задания.

### Структура задания

Тип [`Task`](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.tasks.task?view=net-8.0) обладает набором членов, которые отнимат дополнительные ресурсы. Если эти поля не нужны, то рекомендуется воспользоваться методом `ThreadPool.QueueUserWorkItem()`.

### Фабрики заданий

_Фабрики заданий_ (task factory) используются в ситуациях, когда необходимо создать несколько заданий, находящихся в одном и том же состоянии.

### Планировщики заданий

Объект `TaskScheduler` отвечает за выполнение заплаированных заданий и выводит информацию о них в отладчике. В FCL существует два производных от данного типа: планировщик заданий в пуле потоков и планировщик заданий контекста синхронизации. По умолчанию все приложения используют первый. Второй тип планировщика используется обычно в приложениях с графическим интерфейсом.

## Методы For, ForEach и Invoke класса Parallel



## Встроенный язык параллельных запросов



## Периодические выислительные операции



### Разновидности таймеров



## Как пул управляет потоками



### Ограничение количества потоков в пуле



### Управление рабочими потоками

