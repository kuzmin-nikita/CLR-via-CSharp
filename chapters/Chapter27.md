## Пул потоков в CLR 

CLR способна управлять собственным пулом потоков, то есть набором готовых потоков, доступных для использования приложениями. Для каждого эземпляра CLR существует свой пул, используемый всеми доменами.

При инициализации CLR пул потоков пуст. Для выполнения прилоением асинхронной оперции вызывается метод, размещающий соответстующий зарпос в очереди пула потоков. Код пула извлекает записи из очереди и распределяет и среди потоков пула. Если пул пуст, создаётся новый поток. По завершении задания поток не уничтожается, а возвращается в пул. Благодаря этому производительность не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их все в одном потоке. Однако если приложение создаёт очередь запросов быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки. Такой подход позволяет обойтись небольшим числом потоков.

Когда приложение прекращает отпраывлять запросы в пул, появляются незанятые потоки. Через некоторое время бездействия поток пробуждается и уничтожается, освобождая ресурсы.

Пул потоков позволяет найти компромисс в ситуации, когда малое количество потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами многопроцессорных систем, а также многоядерных и гиперпоптоковых процессоров.

## Простые вычислительные операции

В разделе описываеся добавление асинхронных вычислительных операций в очередь пула потоков с помощью метода `ThreadPool.QueueUserWorkItem()`.

## Контексты исполнения

С каждым потоком связан определённый контекст исполнения, который включает в себя параметры безопасности, параметры хотса и контекстные данные логического вызова.

По умолчанию CLR автоматически копирует контекст исполнения саммого первого потока во все вспомогательные потоки. Это гарантирует безопасность, но в ущерб производительости. С помощью класса `System.Threading.ExecutionContext` можно запретить копирование контекста, что может сильно повычить быстродействие серверных приложений.

## Скоординированная отмена

.NET предлагает стандартный паттерн операций отмены. Этот паттерн является _скоординированным_ (cooperative), то есть требует явной поддержки отмены операций. В состав стандартного паттерна скоординированной отмены входят два типа из FCL: `CancellationTokenSource` (ссылочный тип) и `CancellationToken` (значимый тип). После создания `CancellationTokenSource` можно получить один или несколько экземпляров `CancellationToken`. Затем они передаются операциям, поддерживающим отмену.

Экземпляр `CancellationToken` относится к упрощённому типу, так как содержит одно закрытое поле: ссылку на свой объект `CancellationTokenSource`. Цикл вычислительной операции может периодически обращаться к своейству `CancellationToken.IsCancellationRequested`, чтобы узнать, не требуется ли прерывание операции. Тогда процессор перестаёт совершать операции.

## Задания

Самой большой проблемой при вызове метода `ThreadPool.QueueUserWorkItem()` явялется отсустствие временного механизма, позволяющего узнать о завершении операции и получить возвращаемое значение. Для обхода этих и других ограничений было введено понятие _заданий_ (tasks)? выполнение которых выполняется посредством типов из пространства имён `System.Threading.Tasks`.

### Завершение задания и получение результата



### Отмена задания



### Автоматический запуск задания по завершении предыдущего



### Дочерние задания



### Структура задания



### Фабрики заданий



### Планировщики заданий



## Методы For, ForEach и Invoke класса Parallel



## Встроенный язык параллельных запросов



## Периодические выислительные операции



### Разновидности таймеров



## Как пул управляет потоками



### Ограничение количества потоков в пуле



### Управление рабочими потоками

