## Управлеяемая куча

Любая программа использует ресурсы. В ООП каждый тип идентицицирует некий доступный программе ресурс. Дл пользования этим ресурсом, под него должна быть выделена память. Для доступа к ресурсу нужно:
1. Выделить память для типа, представляющего ресурс (обычно с помощью оператора `new` в C#).
2. Инициализировать выделенную память, установив начальное значение ресурса (за это овтечает конструктор).
3. Использовать ресурс, обращаясь к членам его типа.
4. В рамках процедры очистки уничтожить состояние ресурса.
5. Освободить память (за это овтечает сборщик мусора).

При написании типобезопасного кода (без использования ключевого слова `unsafe`) повреждения в памяти невозможны. Устечки памяти остаются теоретически возможными, но они не происходят в стандартной ситуации. Как правило, утечки памяти возникают из-за того, что приложение хранит объекты в коллекции, но не удаляет их, когда они становятся ненужными.

Ситуация дополнительно упрощается тем, что для большинства типов, регулярно используемых разработчиками, уничтожение состояние ресурса не является обязательным. Таким образом, управляемая куча предоставляет разработчику простую модель программирования: программа выделяет и инициализирует ресурс, после чего использует его так долго, сколько понадобится. Для большиснтва типов очистка ресурсов не нужна, память просто освобождается сборщиком мусора.

При использовании экземпляров типов, требующий специальной очистки, модель программирования остаётся такой же простой. Однако иногда очистка ресурса должна производиться как можно раньше, для этого есть метод `Dispose()`, чтобы очистка была выполнена по собственному расписанию. Как правило, типы, требующие специальной очистки, используют низкоуровневые системные ресурсы - файлы, сокеты или подключения к БД.

### Выделение ресурсов из управляемой кучи

В CLR память для всех ресурсов управляется в _управляемой куче_ (managed heap). При инициализации процесса CLR резервирует область адресного пространства под управляемую кучу, а также указатель на участок памяти, где будет выделено место под следующий объект. Изначально он указывает на базовый адрес зарезервированной области адресного пространства.

По мере заполнния области объектами, CLR выделяет новые области, вплоть до заполнения вссего адресного пространства. Таким образом, память приложения ограничивается виртуальным адресным пространством процесса.

При выполнении оператора `new` среда CLR:
1. Подсчитывает количество байтов, необхолимых для размещения полей типа (и всех полей, унаследованных от базового типа).
2. Прибавляет к полученному значения количество байтовв, необходимое для размещения специальных полей (размер равен разрядности системы).
3. Проверяет, хватает ли в зарезервированной области байтов на выделение памяти для объекта. Если памяти достаточно, то она выделяется, начиная с адреса, который содержится в указателе, а занимаемып им байты обнуляются. Затем вызывается конструкторм типа (передающий казатель в качестве параметра `this`), и оператор `new` возвращает ссылку на объект. Перед возвратом этой ссылки, указатель переходит на новый адрес, куда будет помещён следующий объкт.

Для управляемой кучи выделение памяти сводится к простому увеличению указателя - эта операция выполняется почти мгновенно. Во многих приложениях объекты, выделяемые примерно в одно время, тесно связаны друг с другом. В среде, поддерживающей сборку мусора, новые объекты располагаются непрерывно, что повышает производительность. 

Описание предполагает, что память беспокнечна, а CLR может всегда выделить блок для нового объекта. Конечно, это не так, и управляемой куче необходим мехаизм уничтожения объектов, которые больше не нужны приложениб - _сборка мусора_ (Garbage Collection, GC).

### Алгоритм сборки мусора

Если очень упрощённо описывать работу сборщика мусора, то можно сказать, что сборка выполняется, если при создании объекта с помощью оператора `new` не хватает памяти для создания объекта. В реальности же сборка мусора выполняется при заполнении поколения 0.

Для управления сроком жизни объектом в некоторых системах используется алгоритм подсчёта ссылок. В системах с подсчётом ссылок каждый объект в куче содержит внутреннее поле с информацией о том, сколько "частей" программы в данный момент используют объект. Когда каждая "часть" переходит к точке кода, в которой объект становится недоступным, она уменьшает поле счётчика объекта. Когда значение счётчика уменьшается до 0, объект удаляется из памяти. В таких системах очень часто возникают проблемы с циклическими ссылками. Когда два объекта ссылаются друг на друга, их ссылки не позволяют счётчикам онулиться, в следствие чего ни один их объектов не будет удалён из памяти.

Из-за проблем с подобными алгоритмами, в CLR используется агоритм _отслеживания ссылок_. Данный алгоритм работает только с переменными ссылочного типа, потому что только они могут ссылаться на объекты в куче. Ссылочные переменные могут использоваться во многих контекстах: статические и экземплярные поля классов, аргументы методов, локальные переменные. Все переменные ссылочного типа называются _корнями_ (roots).

Когда CLR запускает сборку мусора, сначала приостанавливаются все потоки в процессе, чтобы во время анализа не изменялось состояние объектов. Затем CLR переходит к этапу сборки мусора, называемому _маркировкой_ (marking). CLR перебирает все объекты в куче, задавая биту в поле индекса блока синхронизации значение 0. Это означает, что все объекты могут быть удалены. Затем CLR проверяет все активные корни и объекты, на которые они ссылаются. Если корень содержит `null`, то он игнорируется.

Если корень ссылается на объект, в поле индекса блока синхронизации устанвливается бит - это и есть признак маркировки объекта. После маркировки объекта CLR проверяет все корни в этом объекте и маркирует объекты, на которые они ссылаются. Встретив уже маркированный объект, сборщик мусора останавливается, чтобы избежать циклических ссылок.

На рисунке показана управляемая куча до сборки мусора. В приложении есть несколько корней, которые ссылаются на объекты A, C, D и F. Кроме того, при маркировке объекта D сборщик заметил, что есть поле, ссылающееся на H, так что H тоже маркируется. А затем продолжается рекурсивный просмотр всех достижимых объектов.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/79ef2c6f-ac16-4ef3-81a6-4a8ccb4cd0c2)

После проверки всех корней куча содержит набор маркированных и немаркированных объектов. Маркированные объекты переживут сборку мусора, так как они достижимы из кода. Немаркированные объекты, соовтветственно, недостижиы, так как не существует ссылающихся на них корней.

После этого начинается следующая фаза - _сжатие_ (compacting phase). В этой фазе CLR перемещает вниз все "немусорные" объекты, чтобы они занимали смежный блок памяти. Перемещение имеет ряд преимуществ:
1. Оставшиеся объекты будут находиться поблизости, что приводит к сокращению размера рабочего набора, а следовательно, повышает производительность обращения к ни.
2. Свободное пространство тоже становится непрерывным, что позволяет освободить эту область адресного пространства.
3. Сжатие позволяет избежать проблем фрагментации адресного пространства.

После перемещения CLR вычитает из каждого корня количество байт, на которое объект был сдвинут, чтобы ссылки остались корректными и выполнение программы продолжилось без ошибок.

После сжатия памяти кучи в указатель `NextObjPtr` заносится первый адрес за последним объектом, не являющимся мусором. После завершения фазы сжатия CLR возобновляет выполнение потоков, а они обращаются к объектам так, будто никакой сборки не было. Результат сборки представлен на рисунке.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/e826f306-eb0c-4cd6-82fd-d13275775ddf)

Если CLR не удалось освободить память в результате сборки мусора, а в процессах не осталось адресного пространства для выделения нового сегмента, значит, свободная память процесса полностью исчерпана. В этом случае возникнет исключение `OutOfMemoryException`. Приложение может попробовать перехватить это исключение и восстановиться, однако большинство приложений не пытается этого сделать: исключение превращается в необработанное, процесс завершается, а вся используемая процессом память освобождается.

Из этого описания можно извлечь несколько моментов:
1. Исключается утечка объектов, так как все недоступные корням объекты рано или поздно уничтожатся сборщиком мусора.
2. Благодаря сборке мусора невозможно получить доступ к особождённому объекту с повследующим повреждением памяти.

Статическое поле типа хранит объект, на который ссылается, бессрочно или до выгрузки домена приложения с загруженными типами. Чаще всего утечка возниикает из-за хранения в статическом поле ссылки на коллекцию, в которую добавляются элементы. Поэтому статических полей следует избегать по возможности.

### Сборка мусора и отладка

Как только объект становится недостижимым, он превращается в кандидата на удаление - объекты далеко не всегда доживают до завершения работы метода. Иными словами, если переменной присвоено значение, но она ни разу не используется, то объект, на который ссылается переменная, становится кандидатом на удаление.

Решить подобную проблему можно в режиме отладки, так как в этом режиме JIT-компилятор искусственно продлевает время жизни объектов до выхода из метода. Однако, в продуктовой версии такое решение не сработает. Для продления времени изни в продуктовой версии необходимо вызвать для перменной метод `Dispose()` там, до куда необходимо продлить жизнь данного объекта.

Однако, подобная проблема актуальна не для всех классов в приложении, а только для некоторых специфичных (например, класс `Timer`). Для всех остальных объектов время жизни определяется автоматические.

## Поколения

_Сборщик мусора с поддержкой поколений_ (generational garbage collector), который также называют _эфемерным сборщиком мусора_ (ephemeral garbage collector), работает на основе следующих принципов:
- Чем младше объект, тем короче его время жизни.
- Чем старше объект, тем длиннее его время жизни.
- Сборка мусора в части кучи выполняется быстрее, чем во всей куче.

Сразу после инициализации в управляемой куче нет объектов. Создаваемые объекты образуют поколение 0. Судя относятся все только что созданные объекты, которых не касался сборщик мусора. Рисунок ниже демонстрирует только что запущенное приложение с пятью объектами в памяти, часть из которых через некоторое время становится недоступна.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/66887aab-a59b-447f-bfb1-c9857d3f88d3)

При инициализации CLR выбирает пороговый ращмер для поколения 0. Если в результате выделения памяти для нового объекта размер поколения 0 превышает пороговое значение, должна начаться сборка мусора. Сборщик мусора определяет, что является мусором и выполняет сжатие памяти. Объекты пережившие сборку мусора старновятся поколением 1. Объекты из поколения 1 были проверены единожды.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/e3a384ec-df45-482e-bb08-228ec63e3d0b)

После сборки мусора объектов в поколении 0 не остаётся. Туда помещаются новые объекты, часть из которых в процессе работы также становится недоступной, поэтому занимаемая ими память рано или поздно должна освободиться.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/e2d97707-f052-49d1-84fc-6f19b8cf0d59)

Допустим, что при попытке размещения объекта L размер поколения 0 превысил пороговое значение, а значит, должна начаться сборка мусора. При этом сборщик мусора решает, какие поколения необходимо обработать. При инициализации CLR выбирает пороговый размер не только для поколения 0, но также для поколения 1.

Начиная сборку, сборщик определяет, сколько памяти занято поколением 1. Пока поколение 1 занимает меньше отведённой памяти, сборщик проверяет только объекты поколения 0. Скорее всего, в поколении 0 окажется много мусора, так как время жизни объектов меньше, и освободится много памяти. А поскольку поколение 1 игнорируется, сборка происходит быстрее.

Кроме того, производительность растёт за счёт выборочной проверки. Если корень или объект ссылается на объект в старшем поколении, сборщик игнорирует все внутренние ссылки старшего объекта, сокращая время построения графа доступных объектов. Возможна ситуация, когда старый объект ссылается на новый. Чтобы не пропустить обновлённые поля, сборщик использует внутренний механизм JIT-компилятора, устанавливающий флаг при изменении ссылочного поля объекта. Он позволяет сборщику выяснить, какие из старых объектов были изменены с последней сборки мусора. Остаётся проверить только стары объекты с изменённыи полями, чтобы выфяснить, не ссылаются ли они на объекты поколения 0. Когда JIT-компилятор создаёт код, модифицирующий ссылочное поле внутри объекта, туда входит вызов барьерного метода записи (write barrier method). Метод проверяет, принадлежит ли объект поколению 1 или 2. Если принадлежит, то устанавивается специальный бит во внутренней таблице. Этот механизм снижает производительность, и производительность падает ещё больше, если объект принадлежит к поколению 1 иои 2.

Тесты быстродейсствия показывают, что сборка мусора в поколении 0 происходит меньше чем за 1 мс.

Сборщик мусора с поддержкой поколений предполагает, что объекты прожившие достаточно долго, продолжат жить и ддальше. Так что велика вероятность, что объекты поколения 1 отанутся живы и впредь. То есть при нахождении мусора в поколении 1 его там, скорее всего, окажется очень мало, и запускать сборку мусора будет нерезонно, так что объект просто останется жить в поколении 1 мусором.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/fbc631d4-fcff-4ff7-8f71-325e6e170c9f)

Все объекты из поколения 0, пережившие сборку мусора, перешли в поколение 1. Приложение 0 снова пустеет, и в нём снова можно выделять память под объекты, часть из которых через время становится недоступными.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/720aae67-5919-4b08-87fb-aa5f5477de16)

В поколении 0 снова произошла сборка мусора, при этом в поколении 1 занято всё ещё меньше порогового значения.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/d7ed3441-f544-4fe6-9f5f-9efddb069c87)

Поколение 1 постепенно растёт. В какой-то момент оно вырастает до таких размеров, что занимаемое объектами место превышает пороговое значение. В этот момент приложение продолжит работать, так как сборка мусора только что произошла, и начинает размещение объектов в поколении 0 до его порогового значения.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/5bc81c28-bd41-4170-ba1d-351ad809eb8b)

При очередной попытке разместить объект в поколении 0, начинается сборка мусора. При этом и в поколении 1 места не хватает. Так как в поколении 0 прошло уже несколько очисток, есть вероятность, что несколько объектов в поколении 1 стали недоступными. Теперь инициирована сборка мусора ещё и в поколении 1. После сборки мусора в обоих поколениях создаётсся поколение 2.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/efe85544-cbe1-408f-85bc-00ca5ed00438)

Все выжившие объекты поколения 0 теперь находятся в поколении 1, а все выжившие в поколении 1 - в поколении 2. В поколении 2 находятся объекты, проверенные сборщиком мусора не менее 2 раз.

Управляемая куча поддерживает только три поколения: 0, 1 и 2. Для всех из них выставляется пороговое значение при инициализации в CLR. Сборщик мусора CLR является самонастраивающимся и подбирает пороговые значения в зависимости от функционала. Если в приложении мало выживающих объектов, тогда поколение 0 будет больше, иначе оно будет меньше.

### Запуск сборки мусора



### Большие объекты



### Режимы сборки мусора



### Программное управление сборщиком мусора



### Мониторинг использования памяти приложением



## Освобождение ресурсов при помощи механизма финализации 



### Типы, использующие системные ресурсы



### Интересные аспекты зависимостей



### Другие возможности сборщика мусора для работы с системными ресурсами



### Внутренняя реализация финализации



## Мониторинг и контроль времени жизни объектов

