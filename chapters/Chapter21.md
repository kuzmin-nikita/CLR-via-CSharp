## Управлеяемая куча

Любая программа использует ресурсы. В ООП каждый тип идентицицирует некий доступный программе ресурс. Дл пользования этим ресурсом, под него должна быть выделена память. Для доступа к ресурсу нужно:
1. Выделить память для типа, представляющего ресурс (обычно с помощью оператора `new` в C#).
2. Инициализировать выделенную память, установив начальное значение ресурса (за это овтечает конструктор).
3. Использовать ресурс, обращаясь к членам его типа.
4. В рамках процедры очистки уничтожить состояние ресурса.
5. Освободить память (за это овтечает сборщик мусора).

При написании типобезопасного кода (без использования ключевого слова `unsafe`) повреждения в памяти невозможны. Устечки памяти остаются теоретически возможными, но они не происходят в стандартной ситуации. Как правило, утечки памяти возникают из-за того, что приложение хранит объекты в коллекции, но не удаляет их, когда они становятся ненужными.

Ситуация дополнительно упрощается тем, что для большинства типов, регулярно используемых разработчиками, уничтожение состояние ресурса не является обязательным. Таким образом, управляемая куча предоставляет разработчику простую модель программирования: программа выделяет и инициализирует ресурс, после чего использует его так долго, сколько понадобится. Для большиснтва типов очистка ресурсов не нужна, память просто освобождается сборщиком мусора.

При использовании экземпляров типов, требующий специальной очистки, модель программирования остаётся такой же простой. Однако иногда очистка ресурса должна производиться как можно раньше, для этого есть метод `Dispose()`, чтобы очистка была выполнена по собственному расписанию. Как правило, типы, требующие специальной очистки, используют низкоуровневые системные ресурсы - файлы, сокеты или подключения к БД.

### Выделение ресурсов из управляемой кучи

В CLR память для всех ресурсов управляется в _управляемой куче_ (managed heap). При инициализации процесса CLR резервирует область адресного пространства под управляемую кучу, а также указатель на участок памяти, где будет выделено место под следующий объект. Изначально он указывает на базовый адрес зарезервированной области адресного пространства.

По мере заполнния области объектами, CLR выделяет новые области, вплоть до заполнения вссего адресного пространства. Таким образом, память приложения ограничивается виртуальным адресным пространством процесса.

При выполнении оператора `new` среда CLR:
1. Подсчитывает количество байтов, необхолимых для размещения полей типа (и всех полей, унаследованных от базового типа).
2. Прибавляет к полученному значения количество байтовв, необходимое для размещения специальных полей (размер равен разрядности системы).
3. Проверяет, хватает ли в зарезервированной области байтов на выделение памяти для объекта. Если памяти достаточно, то она выделяется, начиная с адреса, который содержится в указателе, а занимаемып им байты обнуляются. Затем вызывается конструкторм типа (передающий казатель в качестве параметра `this`), и оператор `new` возвращает ссылку на объект. Перед возвратом этой ссылки, указатель переходит на новый адрес, куда будет помещён следующий объкт.

Для управляемой кучи выделение памяти сводится к простому увеличению указателя - эта операция выполняется почти мгновенно. Во многих приложениях объекты, выделяемые примерно в одно время, тесно связаны друг с другом. В среде, поддерживающей сборку мусора, новые объекты располагаются непрерывно, что повышает производительность. 

Описание предполагает, что память беспокнечна, а CLR может всегда выделить блок для нового объекта. Конечно, это не так, и управляемой куче необходим мехаизм уничтожения объектов, которые больше не нужны приложениб - _сборка мусора_ (Garbage Collection, GC).

### Алгоритм сборки мусора



### Сборка мусора и отладка



## Поколения



### Запуск сборки мусора



### Большие объекты



### Режимы сборки мусора



### Программное управление сборщиком мусора



### Мониторинг использования памяти приложением



## Освобождение ресурсов при помощи механизма финализации 



### Типы, использующие системные ресурсы



### Интересные аспекты зависимостей



### Другие возможности сборщика мусора для работы с системными ресурсами



### Внутренняя реализация финализации



## Мониторинг и контроль времени жизни объектов

