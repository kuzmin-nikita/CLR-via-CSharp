При разработке масштабируемого и быстродействующего приложения стоит избегать блокировки потоков, так как только в этом случае их можно будет использовать повторно.

Синхронизация потоков позволяет предотвратить повреждение общих даных при одновременном доступе к ним из разных потоков. Синхронизация не треуется, если доступ к данным осуществляется так, что потоки никак не мешают друг другу. Асинхронные функции реализованы так, что два потока не будут работать одноверменно с одними данными, поэтому для асинхронных функций синхронизация потоков не нужна.

Синхронизация влечёт ряд проблем:
1. **Сложность разработки.** При разработке необходимо внимательно следить за кодом блокировки и разблокировки данных, а проверить корректную работу можно только с применением нагрузочных тестов (желательно на машине с большим числом процессоров и потоков).
2. **Снижение производительности.** Установление и снятие блокировки требуют времени. Снижение скорости работы зависит от выбранного механизма блокирования, но даже самое быстрое блокирование значительно снижает быстродействие.
3. **Создание дополнительных потоков.** При блокировании допускается доступ к данным только из одного потока. Если при этом поток оказывается заблокированным, пул создаст ещё один для сохранения загрузки процессора. А при снятии блокировки потоков оказывается больше, чем процессоров, что приводит к более частым переключениям контекста.

Следует избегать общах данных (например, статических полей). При создании объекта оператором `new` он доступен только для вызывающего потока, так что необходимость в синхронизации отпадает. Стоит по возможности избегать значимых типов, потому что они всегда копируются и каждый поток работает со своей копией.

Однако, нет ничего страшного в работе нескольких потоков с общими данными, если эти данные предназначены только для чтения.

## Библиотеки классов и безопасность потоков

FCL гарантирует потокобезопасность всех статических методов. То есть вызов статического метода двумя потоками не приводит к повреждению данных. Механизм защиты реализован в FCL, так как нет способа обеспечить блокирование сборок разных производителей, спорящих за доступ к ресурсу. Например, класс `Console` содержит статическое поле, по которому устанавливается и снимается блокировка, гарантируя, что в каждый момент времени доступ к консоли имеет только один поток. Статический метод `System.Math.Max()` безопасен в отношении потоков, так как работает с копиями значимых типов.

В то же время FCL не гарантирует безопасности в отношении потоков экземплярным методам, так как введение в них блокирующего кода слишком сильно скажется на проивзодительности. Более того, если каждый экземплярный метод начнёт выполнять блокирование, это приведёт к тому, что в каждый момент времени будет выполняться только один поток. Но так как экземплярные методы вызываются над объектом, конструируемым в одном потоке, синхронизация не требуется. Однако если в дальнейшем потомок предоставит ссылку на объект (поместив в статическое поле, передав её в качестве аргумента `ThreadPool.QueueUserWorkItem()` или объекту `Task`), тогда синхронизация уже потребуется, если потоки попытаются одновврменно получить доступ к данным не только для чтения.

Собсьтвенные библиотекиклассов стоит строить по вышеописанному паттерну: статические методы должны быть потокобезопасными, а экземплярные - нет.

## Примитивные конструкции пользовательского режима и режима ядра



## Конструкции пользовательского режима



### Volatile-конструкции



### Interlocked-конструкции



### Реализация простой циклической блокировки



### Универсальный Interlocked-паттерн



## Конструкции режима ядра



### События



### Семафоры



### Мьютексы

