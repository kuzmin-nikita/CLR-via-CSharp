При разработке масштабируемого и быстродействующего приложения стоит избегать блокировки потоков, так как только в этом случае их можно будет использовать повторно.

Синхронизация потоков позволяет предотвратить повреждение общих даных при одновременном доступе к ним из разных потоков. Синхронизация не треуется, если доступ к данным осуществляется так, что потоки никак не мешают друг другу. Асинхронные функции реализованы так, что два потока не будут работать одноверменно с одними данными, поэтому для асинхронных функций синхронизация потоков не нужна.

Синхронизация влечёт ряд проблем:
1. **Сложность разработки.** При разработке необходимо внимательно следить за кодом блокировки и разблокировки данных, а проверить корректную работу можно только с применением нагрузочных тестов (желательно на машине с большим числом процессоров и потоков).
2. **Снижение производительности.** Установление и снятие блокировки требуют времени. Снижение скорости работы зависит от выбранного механизма блокирования, но даже самое быстрое блокирование значительно снижает быстродействие.
3. **Создание дополнительных потоков.** При блокировании допускается доступ к данным только из одного потока. Если при этом поток оказывается заблокированным, пул создаст ещё один для сохранения загрузки процессора. А при снятии блокировки потоков оказывается больше, чем процессоров, что приводит к более частым переключениям контекста.

Следует избегать общах данных (например, статических полей). При создании объекта оператором `new` он доступен только для вызывающего потока, так что необходимость в синхронизации отпадает. Стоит по возможности избегать значимых типов, потому что они всегда копируются и каждый поток работает со своей копией.

Однако, нет ничего страшного в работе нескольких потоков с общими данными, если эти данные предназначены только для чтения.

## Библиотеки классов и безопасность потоков

FCL гарантирует потокобезопасность всех статических методов. То есть вызов статического метода двумя потоками не приводит к повреждению данных. Механизм защиты реализован в FCL, так как нет способа обеспечить блокирование сборок разных производителей, спорящих за доступ к ресурсу. Например, класс `Console` содержит статическое поле, по которому устанавливается и снимается блокировка, гарантируя, что в каждый момент времени доступ к консоли имеет только один поток. Статический метод `System.Math.Max()` безопасен в отношении потоков, так как работает с копиями значимых типов.

В то же время FCL не гарантирует безопасности в отношении потоков экземплярным методам, так как введение в них блокирующего кода слишком сильно скажется на проивзодительности. Более того, если каждый экземплярный метод начнёт выполнять блокирование, это приведёт к тому, что в каждый момент времени будет выполняться только один поток. Но так как экземплярные методы вызываются над объектом, конструируемым в одном потоке, синхронизация не требуется. Однако если в дальнейшем потомок предоставит ссылку на объект (поместив в статическое поле, передав её в качестве аргумента `ThreadPool.QueueUserWorkItem()` или объекту `Task`), тогда синхронизация уже потребуется, если потоки попытаются одновврменно получить доступ к данным не только для чтения.

Собсьтвенные библиотекиклассов стоит строить по вышеописанному паттерну: статические методы должны быть потокобезопасными, а экземплярные - нет.

## Примитивные конструкции пользовательского режима и режима ядра

Под "примитивными" подразумеваются простейшие конструкции, которые доступны в коде. Бывают двух видов: пользовательского режима и режима ядра. По возможности стоит использовать первые, так как они быстрее и используют директивы процессора. То есть имеет место координация на аппаратном уровне. Однако одновременно это означает, что Windows не распознаёт такие конструкции и не создаёт дополнительных потоков для выравнивания загрузки процессора. Кроме того, блокировка происходит на короткое время.

Конструкции пользователького режима не идеальны. Только ядро Windows может остановить выполнение потока, чтобы он впустую не расходовал ресурсы процессора. Запущенный в пользовательском режиме поток может быть прерван ОС, но довольно быстро будет снова готов к работе. Получается, если поток будет пытаться, но не сможет получить некоторый ресурс, то он начнёт циклически существовать в пользовательском режиме, что потенциально является пустым расходованием времени процессора.

Именно это заставляет перейти к конструкциям режима ядра. Они предоставляются самой ОС и требуют от потоков вызова функций, реализованных в ядре. Переход потока между пользовательским режимом и режимом ядра требует значительных затрат ресурсов, так что конструкций режима ядра стоит избегать. Однако, у них есть ряд преимущества. Если один поток использует конструкцию режима ядра для получения ресурса, с которым уже работает другой поток, Windows блокирует его, чтобы не тратить время процессора. А после получения доступа к ресурсу блокировка снимается.

Если поток, использующий в данный момент конструкцию, не освободит её, то ожидающий конструкцию поток может оказаться заблокированным навсегда. В этом случае в пользовательском режиме поток будет бесконечно исполняться, это назыввается _активной (живой) блокировкой_ (livelock) или _зависанием_. В режиме ядра поток блокируется навсегда, это называется _взаимной (мёртвой) блокировкой_ (deadlock). Обе блокировки плохи, но вторая является меньшим злом, так как впустую расходуется только память, но не время процессора.

## Конструкции пользовательского режима

CLR гарантирует атомарность записи большинства примитивных типов, то есть все байти читаются или записываются одновременно. При этом посторонние потоки не увидят переменную в промежуточном состоянии.

Для тех примитиыных типов, которые не поддерживают атомарность, сторонний поток можжет получить промежуточное значение. Это называется _прерванным чтением_ (torn read).

Примитивные конструкции пользовательского режима управляют временем выполнения атомарных операций записи или чтения. Кроме того, они обеспечивают атомарность и управление временем выполенния для переменных типов `U(Int64)` и `Double`.

Примитивные констркции делятся на два тпа:
- _Volatile-конструкции_ выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения _или_ записи.
- _Interlocked-конструкции_ выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения и записи.

КОнструкции обоих типов требуют передачи ссылки на переменную.

### Volatile-конструкции

Компилятор C# очень умело опитимизирует код вплоть до того, чтобы исключать участки, которые никогда не будут вызваны. В процессе оптимизации компилятором C#, JIT-компилятором и процессором гарантируется сохранение назначения кода. То есть с точки рения одного потока код выполняется так, как и задумано. хотя не обязательно сохраняя реализацию. Однако при переходе к многопоточной конфигурации ситуация может измениться.

В книге приводится несколько примеров, когда многопоточная конфигурация может повлиять на релизную версию программы, при этом в отладке всё будет работать правильно.

Для решения подобных проблем существует класс [`System.Threading.Volatile`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.volatile?view=net-8.0), который содержит два метода, отключающие оптимизаии:
- `Volatile.Write()` заставляет запиать значение непосредственно в момент обращения. Более ранние загрузки и сохранения должны происходить до вызова этого метода.
- `Volatile.Read()` заставляет считать значение параметра непосредственно в момент обращения. Более поздние загрузки и сохранения должны происходить после вызова этого метода.

Вот так выглядит применение данной конструкции:

```csharp 
internal sealed class ThreadsSharingData
{
  private Int32 m_flag = 0;
  private Int32 m_value = 0;

  // Этот метод выполняется одним потоком
  public void Thread1()
  {
    // ПРИМЕЧАНИЕ. 5 нужно записать в m_value до записи 1 в m_flag
    m_value = 5;
    Volatile.Write(ref m_flag, 1);
  }

  // Этот метод выполняется вторым потоком
  public void Thread2()
  {
    // ПРИМЕЧАНИЕ. Поле m_value должно быть прочитано после m_flag
    if (Volatile.Read(ref m_flag) == 1)
      Console.WriteLine(m_value);
  }
}
```

Вызов метода `Volatile.Write()` гарантирует, что все записи в переменные будут завершены до вызова этого метода. При этом предшествующие операции могут быть выполнены в любом порядке.

Вызов метода `Volatile.Read()` гарантирует, что все чтения переменных будут выполнены после вызова этого метода. При этом последующие операции могут быть выполнены в любом порядке.

#### Поддержка полей Volatile в C# 

Клюевое слово `volatile` может применяться к статическим или экземплярным полям некоторых примитивных типов, а также к перечислимым полям. Доступ к помеченным данным ключевым словом полямвсегда будет происходить в режиме волатильного чтения или записи. 

Ключевое слово `volatile` позволяет переписать метод из примера выше:

```csharp 
internal sealed class ThreadsSharingData 
{
  private volatile Int32 m_flag = 0;
  private Int32 m_value = 0;
  
  // Этот метод исполняется одним потоком
  public void Thread1() 
  {
    // ПРИМЕЧАНИЕ. Значение 5 должно быть записано в m_value перед записью 1 в m_flag
    m_value = 5;
    m_flag = 1;
  }
  
  // Этот метод исполняется другим потоком
  public void Thread2() 
  {
    // ПРИМЕЧАНИЕ. Поле m_value должно быть прочитано после m_flag
    if (m_flag == 1)
    Console.WriteLine(m_value);
  }
}
```

Рихтер считает, что данное ключевое слово создаёт ряд проблем и что можно обойтись без него. Кроме того, волатильное поле нельзя передавать в метод по ссылке, а также они несовместимы с CLS.

### Interlocked-конструкции



### Реализация простой циклической блокировки



### Универсальный Interlocked-паттерн



## Конструкции режима ядра



### События



### Семафоры



### Мьютексы

