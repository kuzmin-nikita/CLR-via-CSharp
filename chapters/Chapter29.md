При разработке масштабируемого и быстродействующего приложения стоит избегать блокировки потоков, так как только в этом случае их можно будет использовать повторно.

Синхронизация потоков позволяет предотвратить повреждение общих данных при одновременном доступе к ним из разных потоков. Синхронизация не требуется, если доступ к данным осуществляется так, что потоки никак не мешают друг другу. Асинхронные функции реализованы так, что два потока не будут работать одновременно с одними данными, поэтому для асинхронных функций синхронизация потоков не нужна.

Синхронизация влечёт ряд проблем:
1. **Сложность разработки.** При разработке необходимо внимательно следить за кодом блокировки и разблокировки данных, а проверить корректную работу можно только с применением нагрузочных тестов (желательно на машине с большим числом процессоров и потоков).
2. **Снижение производительности.** Установление и снятие блокировки требуют времени. Снижение скорости работы зависит от выбранного механизма блокирования, но даже самое быстрое блокирование значительно снижает быстродействие.
3. **Создание дополнительных потоков.** При блокировании допускается доступ к данным только из одного потока. Если при этом поток оказывается заблокированным, пул создаст ещё один для сохранения загрузки процессора. А при снятии блокировки потоков оказывается больше, чем процессоров, что приводит к более частым переключениям контекста.

Следует избегать общих данных (например, статических полей). При создании объекта оператором `new` он доступен только для вызывающего потока, так что необходимость в синхронизации отпадает. Стоит по возможности избегать значимых типов, потому что они всегда копируются и каждый поток работает со своей копией.

Однако, нет ничего страшного в работе нескольких потоков с общими данными, если эти данные предназначены только для чтения.

## Библиотеки классов и безопасность потоков

FCL гарантирует потокобезопасность всех статических методов. То есть вызов статического метода двумя потоками не приводит к повреждению данных. Механизм защиты реализован в FCL, так как нет способа обеспечить блокирование сборок разных производителей, спорящих за доступ к ресурсу. Например, класс `Console` содержит статическое поле, по которому устанавливается и снимается блокировка, гарантируя, что в каждый момент времени доступ к консоли имеет только один поток. Статический метод `System.Math.Max()` безопасен в отношении потоков, так как работает с копиями значимых типов.

В то же время FCL не гарантирует безопасности в отношении потоков экземплярным методам, так как введение в них блокирующего кода слишком сильно скажется на производительности. Более того, если каждый экземплярный метод начнёт выполнять блокирование, это приведёт к тому, что в каждый момент времени будет выполняться только один поток. Но так как экземплярные методы вызываются над объектом, конструируемым в одном потоке, синхронизация не требуется. Однако если в дальнейшем потомок предоставит ссылку на объект (поместив в статическое поле, передав её в качестве аргумента `ThreadPool.QueueUserWorkItem()` или объекту `Task`), тогда синхронизация уже потребуется, если потоки попытаются одновременно получить доступ к данным не только для чтения.

Собственные библиотеки классов стоит строить по вышеописанному паттерну: статические методы должны быть потокобезопасными, а экземплярные - нет.

## Примитивные конструкции пользовательского режима и режима ядра

Под "примитивными" подразумеваются простейшие конструкции, которые доступны в коде. Бывают двух видов: пользовательского режима и режима ядра. По возможности стоит использовать первые, так как они быстрее и используют директивы процессора. То есть имеет место координация на аппаратном уровне. Однако одновременно это означает, что Windows не распознаёт такие конструкции и не создаёт дополнительных потоков для выравнивания загрузки процессора. Кроме того, блокировка происходит на короткое время.

Конструкции пользовательского режима не идеальны. Только ядро Windows может остановить выполнение потока, чтобы он впустую не расходовал ресурсы процессора. Запущенный в пользовательском режиме поток может быть прерван ОС, но довольно быстро будет снова готов к работе. Получается, если поток будет пытаться, но не сможет получить некоторый ресурс, то он начнёт циклически существовать в пользовательском режиме, что потенциально является пустым расходованием времени процессора.

Именно это заставляет перейти к конструкциям режима ядра. Они предоставляются самой ОС и требуют от потоков вызова функций, реализованных в ядре. Переход потока между пользовательским режимом и режимом ядра требует значительных затрат ресурсов, так что конструкций режима ядра стоит избегать. Однако, у них есть ряд преимущества. Если один поток использует конструкцию режима ядра для получения ресурса, с которым уже работает другой поток, Windows блокирует его, чтобы не тратить время процессора. А после получения доступа к ресурсу блокировка снимается.

Если поток, использующий в данный момент конструкцию, не освободит её, то ожидающий конструкцию поток может оказаться заблокированным навсегда. В этом случае в пользовательском режиме поток будет бесконечно исполняться, это называется _активной (живой) блокировкой_ (livelock) или _зависанием_. В режиме ядра поток блокируется навсегда, это называется _взаимной (мёртвой) блокировкой_ (deadlock). Обе блокировки плохи, но вторая является меньшим злом, так как впустую расходуется только память, но не время процессора.

## Конструкции пользовательского режима

CLR гарантирует атомарность записи большинства примитивных типов, то есть все байты читаются или записываются одновременно. При этом посторонние потоки не увидят переменную в промежуточном состоянии.

Для тех примитивных типов, которые не поддерживают атомарность, сторонний поток может получить промежуточное значение. Это называется _прерванным чтением_ (torn read).

Примитивные конструкции пользовательского режима управляют временем выполнения атомарных операций записи или чтения. Кроме того, они обеспечивают атомарность и управление временем выполнения для переменных типов `U(Int64)` и `Double`.

Примитивные конструкции делятся на два типа:
- _Volatile-конструкции_ выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения _или_ записи.
- _Interlocked-конструкции_ выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения и записи.

Конструкции обоих типов требуют передачи ссылки на переменную.

### Volatile-конструкции

Компилятор C# очень умело оптимизирует код вплоть до того, чтобы исключать участки, которые никогда не будут вызваны. В процессе оптимизации компилятором C#, JIT-компилятором и процессором гарантируется сохранение назначения кода. То есть с точки рения одного потока код выполняется так, как и задумано, хотя не обязательно сохраняя реализацию. Однако при переходе к многопоточной конфигурации ситуация может измениться.

В книге приводится несколько примеров, когда многопоточная конфигурация может повлиять на релизную версию программы, при этом в отладке всё будет работать правильно.

Для решения подобных проблем существует класс [`System.Threading.Volatile`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.volatile?view=net-8.0), который содержит два метода, отключающие оптимизации:
- `Volatile.Write()` заставляет записать значение непосредственно в момент обращения. Более ранние загрузки и сохранения должны происходить до вызова этого метода.
- `Volatile.Read()` заставляет считать значение параметра непосредственно в момент обращения. Более поздние загрузки и сохранения должны происходить после вызова этого метода.

Вот так выглядит применение данной конструкции:

```csharp 
internal sealed class ThreadsSharingData
{
  private Int32 m_flag = 0;
  private Int32 m_value = 0;

  // Этот метод выполняется одним потоком
  public void Thread1()
  {
    // ПРИМЕЧАНИЕ. 5 нужно записать в m_value до записи 1 в m_flag
    m_value = 5;
    Volatile.Write(ref m_flag, 1);
  }

  // Этот метод выполняется вторым потоком
  public void Thread2()
  {
    // ПРИМЕЧАНИЕ. Поле m_value должно быть прочитано после m_flag
    if (Volatile.Read(ref m_flag) == 1)
      Console.WriteLine(m_value);
  }
}
```

Вызов метода `Volatile.Write()` гарантирует, что все записи в переменные будут завершены до вызова этого метода. При этом предшествующие операции могут быть выполнены в любом порядке.

Вызов метода `Volatile.Read()` гарантирует, что все чтения переменных будут выполнены после вызова этого метода. При этом последующие операции могут быть выполнены в любом порядке.

#### Поддержка полей Volatile в C# 

Ключевое слово `volatile` может применяться к статическим или экземплярным полям некоторых примитивных типов, а также к перечислимым полям. Доступ к помеченным данным ключевым словом полям всегда будет происходить в режиме волатильного чтения или записи. 

Ключевое слово `volatile` позволяет переписать метод из примера выше:

```csharp 
internal sealed class ThreadsSharingData 
{
  private volatile Int32 m_flag = 0;
  private Int32 m_value = 0;
  
  // Этот метод исполняется одним потоком
  public void Thread1() 
  {
    // ПРИМЕЧАНИЕ. Значение 5 должно быть записано в m_value перед записью 1 в m_flag
    m_value = 5;
    m_flag = 1;
  }
  
  // Этот метод исполняется другим потоком
  public void Thread2() 
  {
    // ПРИМЕЧАНИЕ. Поле m_value должно быть прочитано после m_flag
    if (m_flag == 1)
    Console.WriteLine(m_value);
  }
}
```

Рихтер считает, что данное ключевое слово создаёт ряд проблем и что можно обойтись без него. Кроме того, волатильное поле нельзя передавать в метод по ссылке, а также они несовместимы с CLS.

### Interlocked-конструкции

Класс [`System.Threading.Interlocked`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0) содержит несколько статических методов, каждый из которых выполняет как атомарное чтение, так и атомарную запись. Кроме того, все методы ставят барьер в памяти, то есть любая запись переменной перед вызовом одного из методов выполняется до него, а все чтения - после.

### Реализация простой циклической блокировки

В книге описан пример реализации простой циклической блокировки.

Она достаточно проста, но её потенциальным недостатком является то, что при наличии конкуренции за право на блокирование потоки вынуждены ожидать блокирования в цикле, что приводит к пустому расходованию процессорного времени. Так что использовать циклическую блокировку стоит только для быстро выполнимых операций.

В FCL данная блокировка поставляется вместе со структурой [`System.Threading.SpinWait`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.spinwait?view=net-8.0).

#### Задержка в обработке потока

Хитрость в том, чтобы иметь поток, который мог бы на время заставить ресурс приостановить его, чтобы другой поток, обладающий в данный момент ресурсом, завершился и освободил место. Для этого в структуре `System.Threading.SpinWait` есть ряд методов.

В FCL также существует структура `System.Threading.SpinLock`. Она отличается наличием поддержки времени ожидания.

### Универсальный Interlocked-паттерн

При желании добавить дополнительны методы в `Interlocked` стоит самостоятельно реализовать статические методы, которые бы выполняли желаемые операции через использование `Interlocked.CompareExchange()`.

## Конструкции режима ядра

Преимущества конструкций режима ядра перед конструкциями пользовательского режима:
- Если конструкция выявляет конкуренцию за ресурс, Windows блокирует проигравший поток, останавливая зацикливание, которое ведёт к пустой трате ресурсов.
- Конструкции могут осуществлять взаимную синхронизацию управляемых и неуправляемых потоков.
- Конструкции умеют синхронизировать потоки разных процессов, запущенных на одной машине.
- Конструкции можно наделить атрибутами безопасности, ограничивая несанкционированный доступ к ним.
- Поток можно заблокировать, пока не станут доступны все или хотя бы одна конструкция.
- Поток можно заблокировать конструкцией, указав время ожидания. Если за указанное время поток не получит доступ к ресурсу, его можно разблокировать для выполнения других заданий.

К примитивным конструкциям относятся _события_ (events) и _семафоры_ (semaphores). На их основе строятся более сложные, например, _мьютексы_ (mutex).

Базовым для всех примитивных конструкций режима ядра является абстрактный класс [`System.Threading.WaitHandle`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.waithandle?view=net-8.0).

Конструкции режима ядра часто используются для создания приложений, которые в любой момент времени могут существовать только в одном экземпляре. Пример кода:

```csharp 
using System;
using System.Threading;

public static class Program
{
  public static void Main()
  {
    Boolean createdNew;

    // Пытаемся создать объект ядра с указанным именем
    using (new Semaphore(0, 1, "SomeUniqueStringIdentifyingMyApp", out createdNew))
    {
      if (createdNew)
      {
        // Этот поток создает ядро, так что другие копии приложения не могут запускаться. Выполняем остальную часть приложения...
      } else
      {
        // Этот поток открывает существующее ядро с тем же именем; должна запуститься другая копия приложения.
        // Ничего не делаем, ждем возвращения управления от метода Main, чтобы завершить вторую копию приложения
      }
    }
  }
}
```

### События

События представоляют собой переменные типа `Boolean`, находящиеся под управлением ядра. Ожидающий события поток блокируется, если оно имеет значение `false`, и освобождается, если `true`. Когда событие с автосбросом имеет значение `true`, оно освобождает всего один заблокированный поток, так как после освобождения первого потока ядро автоматические возвращает событию значение `false`. Если значение `true` имеет событие с ручным сбросом, оно освобождает все ожидающие этого потоки.

Если можно избежать синхронизации потоков - следует избегать её. Если без неё не обойтись, стоит использовать конструкции пользовательского режима. Конструкции ядра стоит использовать в самом крайнем случае.

### Семафоры

Семафоры представляют собой обычные переменные типа `Int32`, управляемые ядром. Ожидающий семафора поток блокируется при значении 0 и освобождается при значениях больше 0. При снятии блокировки с ожидающего семафора потока ядро автоматически вычитает единицу из счётчика.

События и семафоры ведут себя следующим образом:
- При наличии нескольких потоков в режиме ожидания событие с автосбросом освобождает только один из них.
- Событие с ручным сбросом снимает блокировку со всех ожидающих его потоков.
- При наличии нескольких потоков, ожидающих семафора, его появление снимает блокировку с потоков `releaseCount`. 

### Мьютексы

Мьютекс предоставляет взаимно исключающую блокировку. Он функционирует аналогично событию с ручным сбросом или семафору, так как за раз освобождает всего лишь один ожидающий поток.

Мьютексы обладают дополнительной логикой:
- Сохраняют информацию о том, какие потоки ими владеют.
- Мьютексы управляют рекурсивным счётчиком, указывающим сколько раз поток-владелец уже владел объектом. Если поток владеет мьютексом и ожидает его ещё раз, рекурсивный счётчик увеличивается на единицу, и потоку разрешается продолжить выполнение. При вызове потоком метода `ReleaseMutex()` рекурсивный счётчик уменьшается на единицу. Как только значение достигнет 0, владельцем мьютекса может стать другой поток.

Из-за этих особенностей мьютексу требуется дополнительная память, поэтому многие разработчики стараются обойтись без мьютексов.
