Одно из ключевых преимуществ ООП - возможность многократного использования кода за счёт наследования. _Обобщения_ (generics) - ещё один механизм, поддерживаемый CLR и языками программирования для другой разновидности многократного использования кода - многократного использования алгоритмов. Разработчик описывает алгоритм, но не указывает тип данных, что позволяет алгоритму работать с несколькими типами данных.

Большинство алгоритмов инкапсулировано в типе. CLR поддерживает создание как обобщённых ссылочных, так и обобщённых значимых типов, но не поддерживает обобщённые перечислимые типы. Кроме того, можно создавать обобщённые интерфейсы и делегаты, а также обобщённые методы, определённые в ссылочным и значимом типах или в интерфейсах.

При определение обобщённого типа или метода переменные, указанные вместо типа (например, `T`), называются _параметрами типа_ (type parameters). `T` — это имя переменной, которое применяется в исходном коде везде, где используется соответствующий тип.

В рекомендация Microsoft указано, что тип должен называться T или начинаться с T (например, TKey или TValue).

При использовании обобщённого типа данных или метода, разработчик передаёт необходимый ему тип в качестве _аргумента-типа_ (type arguments).

Главные преимущества обобщений для разработчиков:
- **Защита исходного кода.** Разработчику, использующему обобщённый алгоритм, не нужен доступ к исходному коду.
- **Безопасность типов.** Когда обобщение применяется с конкретным типом, компилятор и CLR понимают это и следят за тем, чтобы алгоритм был типобезопасным. Иначе это приведёт к ошибке компиляции или во время выполнения.
- **Более простой и понятный код.** В исходном коде требуется меньше операций приведения, так как тип разрешается на этапе компиляции.
- **Повышение производительности.** До появления обобщений подобный механизм реализовывался через тип `object`. Это вызывало необходимость упаковки и распаковки, а также выделения памяти в куче для значимых типов и вызов сборщика мусора. Появление обобщений оптимизировало данную работу.

## Обобщения в библиотеке FCL 

Обобщения применяются к классам коллекций и в FCL определено несколько таких обобщённых классов. Также имеются безопасные в отношении потоков классы коллекций. Microsoft рекомендует использовать именно обобщённые классы коллекций по нескольких причинам:
- Необобщённые классы коллекций не обеспечивают безопасность типов, простоту и понятность кода, а также повышение производительности.
- У обобщённых классов лучше объектная модель (например, меньше виртуальных методов, что повышает производительность).

Классы коллекций реализуют множество интерфейсов, а объекты, добавляемые в коллекции, могут реализовывать интерфейсы, используемые классами коллекций для таких операций, как сортировка и поиск.

Новые обобщённые интерфейсы не заменяют необобщённые, а дополняют их с целью обеспечить обратную совместимость.

## Инфраструктура обобщений

Поддержка обобщений была добавлена в CLR 2.0. Для поддержания работы обобщений было сделано следующее:
- Созданы новые IL-команды, работающие с аргументами типа.
- Изменён формат существующих таблиц метаданных для выражения имён типов и методов с обобщёнными параметрами.
- Обновлены многие языки программирования, чтобы добавить поддержку обобщений.
- Изменены компиляторы для генерации новых IL-команд и изменённого формата метаданных.
- Изменён JIT-компилятор, чтобы он обрабатывал новые IL-команды.
- Созданы новые члены рефлексии.
- Определены новые члены, предоставлявшие информацию рефлексии, чтобы разработчики могли создавать определения обобщённых типов и методов во время исполнения.
- Изменён отладчик, чтобы он поддерживал обобщение.
- Изменена функция IntelliSense для отображения конкретных прототипов членов при использовании обобщённого типа.

### Открытые и закрытые типы

Для  каждого типа, применяемого в приложении, CLR создаёт внутреннюю структуру данных. Эти структуры называются _объектами-типами_ (type objects). Обобщённый тип также считается типом, и для него CLR также создаёт объект-тип. Это справедливо для классов, структур, интерфейсов и делегатов. Тип с обобщёнными параметрами-типами называют _открытым типом_ (open types), а в CLR запрещено конструировании экземпляров обобщённых типов (как и экземпляров интерфейсов).

При ссылке на обобщённый тип в коде можно определить набор обобщённых аргументов типа. Если всем аргументам определённого типа передаются действительные типы данных, то он становится _закрытым типом_ (closed type). CLR разрешает создание экземпляров закрытых типов. Тем не менее в коде, ссылающемся на обобщённый тип, можно не определять все обобщённые аргументы типа. Тогда в CLR создастся объект открытого типа, экземпляры которого создавать нельзя.

Имена обобщённых типов заканчиваются одинарной кавычкой (`), за которой следует число, означающее _арность_ (arity) типа, то есть число необходимых для него параметров типа.

CLR размещает статические поля типа в объекте-типе. Следовательно, каждый закрытый тип имеет свои статические поля. Иначе говоря, статические поля различных обобщённых типов не будут использоваться вместе, потому что у каждого объекта закрытого типа есть свои статические поля. Статический конструктор в обобщённом типе выполняется единожды для каждого закрытого типа.

В CLR существует механизм _ограничений_ (constraints), предлагающий более удачный инструмент определения обобщённого типа с указанием допустимых для него аргументов типа. 

### Обобщённые типы и наследование

Обобщённый тип может быть производным от других типов. При использовании обобщённого типа с указанием аргументов типа в CLR определяется новый объект-тип, производный от того же объекта, что и обобщённый тип. Понимание того, что определение аргументов типа не имеет ничего общего с наследованием, помогает разобраться, какие приведения типов допустимы.

Например, если разработчик хочет создать связный список с разными типами данных в узлах, он может использовать `object`, однако это не безопасно по типам и не производительно из-за упаковки. В данном случае лучше определить базовый тип как необобщённый и наследовать обобщённый типы от него. 

### Идентификация обобщённых типов

Синтаксис обобщённых типов часто приводит разработчиков в замешательство, так как в исходном коде появляется много знаков < и >, что затрудняет чтение. Для упрощения синтаксиса можно создать новый необобщённый тип класса, производный от обобщённого и определяющий все необходимые аргументы типа.

```csharp
// Если нужно упростить данный код
List<DateTime> dt = new List<DateTime>();

// То можно определить такой класс
internal sealed class DateTimeList : List<DateTime>
{
  // Здесь никакой код добавлять не нужно!
}

// И тогда вызывать его будет проще
DateTimeList dt = new DateTimeList();
```

Этот вариант удобен, однако его ни в коем случае нельзя использовать только затем, чтобы упростить чтение исходного кода. Причина проста: пропадает тождественность и эквивалентность типов. Нельзя передать `List<DateTime>` туда, где определён `DateTimeList`, потому что его нельзя будет привести. А наоборот можно. И всё это вызывает путаницу.

К счастью, это можно обойти с использованием ссылки на обобщённый закрытый тип. Для этого необходимо определить псевдоним данного типа в начале файла с использованием директивы `using`.

### Разрастание кода

При JIT-компиляции обобщённого метода CLR подставляет в IL-код метода указанные аргументы-типы, а затем создаёт машинный код для данного метода, работающий с конкретными данными. Это и является одной из основных функций обобщения. Но в таком подходе есть и недостаток, так как машинный код генерируется для каждого сочетания "метод + тип", что приводит к _разрастанию кода_ (code explosion). В итоге рабочий набор приложения существенно увеличивается, снижая производительность.

В CLR есть несколько механизмов оптимизации, призванных предотвратить разрастание кода. Во-первых, если метод вызывается для конкретного типа и позже он опять вызывается с тем же аргументом типа, то код для такого сочетания генерируется единожды, даже если тип используется в разных сборках (но в одном домене приложений).

Кроме того, CLR считает все аргументы ссылочного типа тождественными, что опять же обеспечивает совместное использование кода. По сути, для всех ссылочных типов используется одинаковый код. CLR выполняет эту оптимизацию потому, что все аргументы и переменные ссылочного типа являются всего лишь указателями на объекты в куче, а все операции с указателями выполняются одинаково.

Но если аргументы типа относятся к значимому типу, CLR должна сгенерировать машинный код именно для этого значимого типа. Это объясняется тем, что у значимых типов может быть разный размер. И даже если у типов будет одинаковый размер, CLR всё равно не сможет использовать для них единый код, так как для обработки этих значений могут применяться разные машинные команды.

## Обобщённые интерфейсы

Основное преимущество обобщений - способность определять обобщённые ссылочные и значимые типы. Но для CLR также важна поддержка обобщённых интерфейсов. Без них любая попытка работы со значимым типом через необобщённый интерфейс всегда будет приводить к необходимости упаковки и потере типобезопасности в процессе компиляции, что сильно бы сузило область применения обобщённых типов. Ссылочный и значимый типы реализуют обобщённый интерфейс путём задания аргументов-типов, или же любой тип реализует обобщённый интерфейс без указания аргументов-типов.

## Обобщённые делегаты

Поддержка обобщённых делегатов позволяет передавать методам обратного вызова любые типы объектов, обеспечивая при этом безопасность типов. Более того, благодаря обобщённым делегатам экземпляры значимого типа могут передаваться методам обратного вызова без упаковки. Делегат — это определение класса с помощью четырёх методов: конструктора и методов `Invoke`, `BeginInvoke` и `EndInvoke`. При определении типа делегата с параметрами типа, компилятор задаёт методы класса делегата, а параметры типа  применяются ко всем методам, параметры и возвращаемые значения которых относятся к указанному параметру типа.

Там, где это возможно, рекомендуется использовать обобщённые делегаты `Action<>` и `Func<>` из библиотеки FCL.

### Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах

Каждый из параметров-типов обобщённого делегата должен быть помечен как ковариантный или контравариантный. Это позволяет осуществлять приведение типа переменной обобщённого делегата к _тому же типу делегата_ с другим параметром-типом. Параметры могут быть:
- **Инвариантными.** Параметр-тип не может изменяться.
- **Контравариантными.** Параметр-тип может быть преобразован от класса к классу, производному от него. В C# контравариантный тип помечается ключевым словом `in`. Контравариантный параметр-тип может появляться только во входной позиции, например, в качестве аргументов метода.
- **Ковариантными.** Аргумент-тип может быть преобразован от класса к одному из его базовых классов. В C# ковариантный тип помечается ключевым словом `out`. Ковариантный параметр обобщённого типа может появляться только в выходной позиции, например, в качестве возвращаемого методом значения.

Вариантность действует только в том случае, если компилятор может установить возможность преобразования ссылок между типа. Вариантность неприменима для значимых типов из-за необходимости упаковки. Вариантность также недопустима для параметра-типа, если он передаётся по ссылке.

При использовании обобщённых делегатов стоит использовать вариантность везде, где это возможно, так как это приводит к большему количеству возможных сценариев и не приводит к нежелательным последствиям. Инвариантность применима также и к параметрам-типам интерфейсов.

## Обобщённые методы

При определении обобщённых типов или интерфейсов, определённые в них методы также могут быть обобщёнными и использовать параметр-тип типа. Параметр-тип можно использовать для параметров метода, возвращаемого значения, а также локальных переменных внутри метода. Кроме того, методы могут иметь собственные параметры-типы.

### Обобщённые методы и выведение типов

Синтаксис обобщений в C# может приводить разработчиков в замешательство, поэтому с целью упростить создание, чтение и работу с кодом компилятор предлагает _логическое выведение типов_ (type inference) при вызове обобщённых методов. Это значит, что компилятор пытается определить (_логически вывести_) тип, который будет использоваться при вызове обобщённого метода. При выполнении логического выведения используется тип переменной, а не тип объекта, на который ссылается эта переменная.

Тип может определять таким образом несколько методов таким образом, что один из них будет принимать конкретный тип данных, а другой - обобщённый параметр тип. В этом случае компилятор отдаёт предпочтение явному методу.

## Обобщения и другие члены

В C# у свойств, индексаторов, событий, операторных методов и деструкторов не может быть параметров-типов. Однако их можно определить в обобщённом типе, чтобы в их коде использовать параметры-типы этого типа.

## Верификация и ограничения

В процессе компиляции обобщённого кода компилятор анализирует его, чтобы убедиться, что он сможет работать с любыми типами данных - существующими и теми, которые будут определены в будущем. По умолчанию параметр-типа ограничен `System.Object` и ему доступны операции только этого типа. Для того, чтобы расширить возможный функционал, CLR и компиляторы поддерживают механизм _ограничений_ (constraints). Ограничение сужает перечень типов, которые можно передать в обобщённом тип, и расширяет возможности по работе с этими типами. Создать ограничение можно с использованием маркера `where`. 

При создании закрытого типа компилятор должен проверить, что переданный аргумент-тип удовлетворяет ограничениям, и выдать ошибку в случае несовпадения типов.

Ограничения можно применять к параметрам типов как в обобщённых типах, так и в обобщённых методах. CLR не поддерживает перегрузку по именам параметров или по именам ограничений, а только по арности метода.

При переопределении виртуального обобщённого метода в переопределяющем методе должна совпадать арность, а также он наследует все ограничения. Собственно, переопределяемый метод не вправе задавать ограничения для своих параметров-типов, но может их переименовывать параметры-типы. Аналогично при реализации обобщённого метода интерфейса.

### Основные ограничения

В параметре-типе можно задать не более одного основного ограничения. Основным ограничением может быть ссылочный тип, указывающий на незапечатанный класс, кроме `System.Object`, `System.Array`, `System.Delegate`, `System.MulticastDelegate`, `System.ValueType`, `System.Enum` и `System.Void`. При задании ограничения ссылочного типа для компилятора гарантируется, что заданный аргумент-тип будет относиться либо у указанному типу, либо к производному от него. Если основное ограничение не задано, то установлен `System.Object`. 

Есть два особых ограничения: `class` и `struct`. Данные ограничения говорят компилятору, что аргумент-тип, будет, соответственно ссылочным или значимым типом.

### Дополнительные ограничения

Для параметра-типа могут быть заданы нуль и более дополнительных ограничений. В качестве дополнительного ограничения можно указать один или несколько интерфейсу, что сообщает компилятору о том, что аргумент-тип должен реализовывать все эти интерфейсы.

Другой тип дополнительных ограничений называют _ограничением параметра-типа_ (type parameter constraint). Например, можно сообщить компилятору, что один из параметров-типов должен быть совместим с другим (был наследником или реализовывал интерфейс).

### Ограничения конструктора

Для параметра-типа можно задать не более одного ограничения на то, чтобы он был неабстрактным типом с открытым конструктором без параметров.

### Другие проблемы верификации

В оставшейся части приводятся несколько конструкций, которые из-за проблем с верификацией ведут себя непредсказуемо, и показано, как с помощью ограничений сделать их верифицируемыми.

#### Приведение переменной обобщённого типа

Приведение переменной обобщённого типа к другому типу допускается только в случае, если она приводится к типу, совместимому с ограничением. Для всех типов это можно сделать через  `object`, однако можно получить `InvalidCastException`. Для ссылочных типов можно использовать оператор `as`.

#### Присваивание переменной обобщённого типа значения по умолчанию

Присваивать `null` не всегда возможно, так как не все параметры-типы поддерживают это значение. Данную проблему можно обойти с применением ключевого слова `default`. 

#### Сравнение переменной обобщённого типа с null

Сравнивать с `null` можно, однако для значимого типа есть пара вариантов:
- При применении оператора `==` тело `if` не будет скомпилировано в машинный код, так как никогда не вызовется.
- При применении оператора `!=` не будет сгенерирован код для инструкции `if`, потому что оно всегда истинно, но тело будет скомпилировано.

Кстати, при применении ограничения `struct` данный код вызовет ошибку компиляции.

#### Сравнение двух переменных обобщённого типа

Сравнение двух переменных через `==` доступно, если оба операнда являются ссылочными.

#### Использование переменных обобщённого типа в качестве операндов

На данный момент нет возможности использовать операторы в обобщённом методе, так как он не знает их тип и нельзя поставить ограничение на использование, например, примитивного типа.
