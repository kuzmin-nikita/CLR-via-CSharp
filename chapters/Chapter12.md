Одно из ключевыхпреимуществ ООП - возможность многократного использования кода за счёт наследования. _Обобщения_ (generics) - ещё один механизм, поддерживаемый CLR и языками программирования для другой разновидности многократного использования кода - многократного использования алгоритмов. Разработчик описывает алгорит, но не указывает тип данных, что позволяет алгоритму работать с несколькими типами данных.

Большинство алгоритмов инкапсулировано в типе. CLR поддерживает создание как обобщённых ссылочных, так и обобщённых значимых типов, но не поддерживае обобщённые перечислимые типы. Кроме того, можно создавать обобщённые интерфейсы и делегаты, а также обобщённые методы, определённые в ссылочным и значимом типах или в интерфейсах.

При определение обобщённого типа или метода переменные, указанные вместо типа (например, `T`), называются _параметрами типа_ (type parameters). `T` - это имя переменной, которое применяется в исходном коде везде, где используется соответствующий тип.

В рекомендация Microsoft указано, что тип должен называться T или начинаться с T (например, TKey или TValue).

При использовании обобщённого типа данных или метода, разработчик передааёт необходимый ему тип в качестве _аргумента-типа_ (type argements).

Главные преимущества обобщений для разработчиков:
- **Защита исходного кода.** Разработчику, использующему обобщённый алгоритм, не нужен доступ к исходному коду.
- **Безопасность типов.** Когда обобщение применяется с конкретным типом, компилятор и CLR понимают это и следят за тем, чтобы алгоритм был типобезопасным. Иначе это приведёт к ошибке компиляции или во время выполнения.
- **Более простой и понятный код.** В исходном коде требуется меньше операций приведения, так как тип разрешается на этапе компиляции.
- **Повышение производительности.** До появления обобщений подобный механизм реализовывался через тип `object`. Это вызывало необходимость упаковки и распаковки, а также выделения памяти в куче для значимых типов и вызов сборщика мусора. Появление обобщений оптимизировало данную работу.

## Обобщения в библиотеке FCL 

Обобщения применяются к классам коллекций и в FCL определено несколько таких обобщённых классов. Также имеются безопасные в отношении потоков классы коллекций. Microsoft рекомендует использовать именно обобщённые классы коллекций по нескольких причинам:
- Необобщённые классы коллекций не обеспечивают безопасность типов, простоту и понятность кода, а также повышение производительности.
- У обобщённых классов лучше объектная модель (например, меньше виртуальных методов, что повышает производительность).

Классы коллекций реализуют мноество интерфейсов, а обекты, добавляемые в коллекции, могут реализовывать интефрейсы, испоьзуемые классами коллекций для таких операций, как сортировка и поиск.

Новые обобщённые интерфейсы не заменяют необобщённые, а дополняют их с целью обеспечить обратную совместимость.

## Инфрастуктура обобщений

Поддержка обобщений была добавлена в CLR 2.0. Для поддержания работы обобщений было сделано слудующее:
- Созданы новые IL-команды, работающие с аргументами типа.
- Изменён формат существующих таблиц метаданных для выражения имён типов и методов с обобщёнными параметрами.
- Обновлены многие языки программирования, чтобы добавить поддержку обобщений.
- Изменены компиляторы для генерации новых IL-команд и изменённого формата метаданных.
- Изменён JIT-компилятор, чтобы он обрабатывал новые IL-команды.
- Созданы новые члены рефлексии.
- Определены новые члены, предоставлявшие информацию рефлексии, чтобы разработчики могли создавать опредления обобщённых типов и методов во время исполнения.
- Изменён отладчик, чтобы он поддерживал обобщение.
- Изменена функция IntelliSense для отображения конкретных прототипов членов при использовании обобщённого типа.

### Открытые и закрытые типы

Для  каждого типа, применяемого в приложении, CLR созаёт внутреннюю структуру данных. Эти структуры называются _объектами-типами_ (type objects). Обобщённый тип также считается типом, и для него CLR также создаёт объект-тип. Это справедливо для классво, структур, интерфейсов и делегатов. Тип с обобщёнными параметрами-типами называют _откртым типом_ (open types), а в CLR запрещено конструировани экземпляров обобщённых типов (как и экземпляров интерфейсов).

При ссылке на обобщённый тип в коде можно определеить набор обобщённых аргументов типа. Если всем аргументам определённого типа передаются действительные типы данных, то он становится _закрытым типом_ (closed type). CLR разрешает создание экземпляров закрытых типов. Тем не менее в коде, ссылающемся на обобщённый тип, можно не определять все обобщённые аргументы типа. Тогда в CLR создастся объект открытого типа, экземпляры которого создавать нельзя.

Имена обобщённых типов заканчиваются одинарной кавычкой (`), чза которой следует число, означающее _арность_ (arity) типа, то есть число необходимых для него параметров типа.

CLR размещает статические поля типа в объекте-типе. Следовательно, каждый закрытый тип имеет свои статические поля. Иначе говоря, статические поля различных обобщённых типов не будут использоваться вместе, потому что у каждого объекта закрытого типа есть свои статические поля. Статический кконструктор в обобщённом типе выполняется единожды для каждого закрытого типа.

В CLR существует мезанизм _ограничений_ (constraints), предлагащий более удачный инструмент определения обобщённого типа с указанием допустимых для него аргументов типа. 

### Обобщённые типы и наследование

Обобщённый тип может быть производным от дргуих типов. При использовании обобщённого типа с указанием аргументов типа в CLR определяется новый объект-тип, производный от того же объекта, что и обобщённый тип. Понимание того, что определение аргументов типа не имеет ничего общего с наследованием, помогает разобраться, какие приведения типов допустимы.

Например, если разработчик хочет создать связный список с разными типами данных в узлах, он может использовать `object`, однако это не безопасно по типам и не производительно из-за упаковки. В данном случае лучше определить базовый тип как необобщённый и наследовать обобщённый типы от него. 

### Индентификация обобщённых типов

Синтаксис обобщённых типов часто приводит разработчиков в замешательство, так как в исходном коде появляется много знаков < и >, что затрудняет чтение. Для упрощения синтаксиса можно создать новый необобщённый тип класса, производный от обобщённого и определяющий все необходимые аргументы типа.

```csharp
// Если нужно упростить данный код
List<DateTime> dt = new List<DateTime>();

// То можно определить такой класс
internal sealed class DateTimeList : List<DateTime>
{
  // Здесь никакой код добавлять не нужно!
}

// И тогда вызывать его будет проще
DateTimeList dt = new DateTimeList();
```

Этот вариант удобен, однако его ни в коем случае нельзя использовать только затем, чтобы упростить чтение исходного кода. Причина проста: пропадает тождественность и эквивалентность типов. Нельзя передать `List<DateTime>` туда, где определён `DateTimeList`, потому что его нельзя будет привести. А наоборот можно. И всё это вызывает путаницу.

К счатью, это можно обойти с использованием ссылки на обобщённый закрытый тип. Для этого необходимо определить псевдоним данного типа в начале файла с использованием директивы `using`.

### Разрастание кода

При JIT-компиляции обобщённого метода CLR подставляет в IL-код метода указанные аргументы-типы, а затем создаёт машинный код для данного метода, работающий с конкретными данными. Это и является одной из основных функций обобщения. Но в таком подходе есть и недостаток, так как машинный код генерируется для каждого сочетания "метод + тип", что приводит к _разрастанию кода_ (code explosion). В итоге рабочий набор приложения существенно увеличивается, снижая производительность.

В CLR есть несколько механизмов оптимизации, призванных предотвратить разрастание кода. Во-первых, если метод вызывается для конкретного типа и позже он опять вызывается с тем же аргументом типа, то код для такого сочетания генерируется единожды, даже если тип используется в разных сборках (но в одном домене приложений).

Кроме того, CLR считае т все аргументы ссылочного типа тождественными, что опять же обеспечивает совместное использование кода. По сути, для всех ссылочных типов используется одинаковый код. CLR dsgjkyzztn эту оптимизацию потому, что все аргументы и переменные ссылочного типа являются всего лишь указателями на объекты в куче, а все опреации с указателями выполняются одинаково.

Но если аргументы типа относятся к значимому типу, CLR должна сгенерировать машинный код именно для этого значиого типа. Это объясняется тем, что у значимых типов может быть разный размер. И даже если у типов будет одинаковый размер, CLR всё равно не сможет использовать для них единый код, так как для обработики этих значений могут применяться разные машинные команды.

## Обобщённые интерфейсы



## Обобщённые делегаты



### Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах



## Обобщённые методы



### Обобщённые методы и выведение типов



## Обобщения и другие члены



## Верификация и ограничения



### Основные ограничения



### Дополнительные ограничения



### Ограничения конструктора



### Другие проблемы верификации

