Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллкцию. CLR поддерживает _одномерные_ (single-dimension), _многомерные_ (multidimension) и _нерегулярные_ (jagged) массивы/ Базовым для всех массивов является абстрактный класс `System.Array`, производный от `System.Object`, а значит массивы являются ссылочным типом, хранятся в куче, а переменная в коде содержит не элементы массива, а ссылку на массив.

Ниже представлен код и визуализация в памяти созданий и изменений массивов различных типов.

```csharp
Int32[] myIntegers; // Объявление ссылки на массив
myIntegers = new Int32[100]; // Создание массива типа Int32 из 100 элементов

Control[] myControls; // Объявление ссылки на массив
myControls = new Control[50]; // Создание массива из 50 ссылок на переменную Control

myControls[1] = new Button();
myControls[2] = new TextBox();
myControls[3] = myControls[2]; // Два элемента ссылаются на один объект
myControls[46] = new DataGrid();
myControls[48] = new ComboBox();
myControls[49] = new Button();
```

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/4f94509c-ce1c-4ec0-b4be-73bf2e37e785)

В данном случае происходит следующее. В первой строке объявляется переменная, которая будет ссылаться на одномерные массив и ей присваивается значение `null`, так как память пока не выделена. Затем выделяется память под 100 значений и всем им присваивается 0. Помимо элементов здесь этот объект хранит типичные для объекта в куче поля. Адрес данного массива заносится в переменную. Во втором блоке кода создаётся массив из элементов ссылочного типа. Смысл тот же, только вместо нулей элементы массива заполняются `null`. В третьем блоке кода происходит частичное заполнение массива так, как если бы те же объекты создавались в качестве переменных.

Согласно CLS? нумерация элементов массива начинается с нуля. Иные варианты нумерации в CLR допускаются, но не приветствуются. 

В массиве всегда присутствует некая дополнительная информация: данные о размерности, типе данных, нижней границе и так далее.

По возможности нужно ограничиваться созданием одномерных массивов с нулевым начальным индексом (их иногда называют _SZ-массивами_ или _векторами_). Векторы обеспечивают наилучшую производительность, так как для них используются IL-команды. Однако, можно создавать и многомерные массивы:

```csharp 
// Создание двухмерного массива типа Doubles
Double[,] myDoubles = new Double[10, 20];

// Создание трехмерного массива ссылок на строки
String[,,] myStrings = new String[5, 3, 10];
```

CLR поддерживает также нерегулярные массивы - массивы массивов. Производительность одномерных нерегулярных массивов с нулевым начальным индексом такая же, как у обычных векторов. Однако обращение к элементам нерегулярного массива означает обращение к двум или более массивам одновременно.

```charp
// Создание одномерного массива из массивов типа Point
Point[][] myPolygons = new Point[3][];

// myPolygons[0] ссылается на массив из 10 экземпляров типа Point
myPolygons[0] = new Point[10];

// myPolygons[1] ссылается на массив из 20 экземпляров типа Point
myPolygons[1] = new Point[20];

// myPolygons[2] ссылается на массив из 30 экземпляров типа Point
myPolygons[2] = new Point[30];

// вывод точек первого многоугольника
for (Int32 x = 0; x < myPolygons[0].Length; x++)
{
  Console.WriteLine(myPolygons[0][x]);
}
```

CLR проверяет корректность индексов. При попытках обратиться к элементу с индексом, выходящим за границы, выбрасывается исключение `System.Index.OutOfRange`, так как доступ к памяти за пределами границ массивов может нарушить безопасность типов и создать брешь в защите, недопустимую для верифицированного кода. Проверка индекса обычно не влияет на скорость, так как происходит заранее перед началом цикла, а не на каждой итерации. Однако эту проверку можно обойти (и увеличить производительность) с помощью небезопасного кода.

## Инициализация элементов массива

Синтаксис C# позволяет объединить операции создания массива и присвоения ему начальных значений:

```charp
String[] names = new String[] { "Aidan", "Grant" };
```

Набор разделённых запятой символов в фигурных скобках называется _инициализатором массива_ (array initializer). Сложность каждого символа может быть проивзольной, а в случае многомерного массива иниицализатор может оказаться вложенным. Данную операцию можно сократить ещё сильнее с помощью неявной типизации (в данном случае компилятор выбирает наиболее подходящий тип из всех):

```csharp
var names = new[] { "Aidan", "Grant", null };
```

Однако, нельзя совмещать, например, строки и числа, так как в этом случае компилятор будет считать, что наиболее подходящим типом является `object`, а значит, необходима упаковка, которую компилятор откажется делать неявно ввиду высоких затрат.

В качестве бонуса существует вот такая возможность инициализации (в данном случае компилятор не разрешает неявную типизацию):

```csharp 
String[] names = { "Aidan", "Grant" };
```

В качестве символов инициализатора могут выступать и объекты анонимного типа (в данном случае объекты массива должны быть экземплярами одного и того же анонимного типа):

```charp 
var kids = new[] {new { Name="Aidan" }, new { Name="Grant" }};
```

## Приведение типов в массивах



## Базовый класс System.Array 



## Реализация интерфейсов IEnumerable, ICollection и IList



## Передача и возврат массивов



## Массивы с ненулевой нижней границей



## Внутренняя реализация массивов



## Небезопасный доступ к массивам и массивы фиксированного размера

