## Конструкторы экземпляров и классы (ссылочные типы)

Конструкторы - специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В таблице определений в метаданных отмечаются сочетанием .ctor (от _constructor_). При создании экземпляра ссылочного типа выделяется память для полей данных и инициализируются службеные поля (индекс блока синхронизации и ссылка на объект-тип), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта.

При конструировании объекта ссылочного типа выделяемая для него память обнуляется до вызова конструктора экземпляра: любые поля, не задаваемые конструктором явно, гарантировано содержат 0 ли `null`.

В отличие от других методов конструкторы экземпляров не наследуются: у класса есть только те конструкторы, которые определены в классе. Невозможность наследования означает, что к конструкторам невозможно применить [модификаторы наследования](https://github.com/kuzmin-nikita/CLR-via-CSharp/blob/c08df41785e910996ddf85b5bdd678b292b02a80/chapters/Chapter6.md?plain=1#L82). Если определить класс без явно заданных конструкторов, компилятор создаст конструктор по умолчанию, который просто вызывает конструктор без параметров базового класса.

Для абстрактных классов компилятор создаёт конструктор с модификатором `protected`, иначе область видимости будет открытой. Если в базовом классе нет конструктора без параметров, производный класс должен явно вызывать конструктор базовго класса, иначе компилятор вернёт ошибку. Для статических классов компилятор не создаёт конструктор по умолчанию.

В типе можно определить несколько конструкторов, при этом сигнатуры и уровни доступа должны отличаться. В случае верифицируемого кода конструктор экземпляров должен вызвать конструктор базового класса до обращения к какому-либо из унаследованных от него полей. В конечном счёте всегда вызывается конструктор `System.Object`, который ниего не делает, а только возвращает управление, так как в `object` не определены поля.

В редких случаях экземпляр может создаваться без вызова конструктора. Например, метод `MemberwiseClone()` выделяет память, инициализирует служебные поля объекта, а потом копирует байты исходного объекта в новую область памяти. Кроме того, конструктор обычно не вызывается при десериализации.

Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут повлиять на создаваемый объект. Потому что если виртуальный метод переопределён в проивзодном типе, то реализация производного типа вызовется до того, как завершится инициализация всех полей в иерархии. В таких обстоятельствах последсьвия вызова непредсказуемы.

Если имеется несколько инициализируемых экземплярных полей и множество перегруженных конструкторов, стоит подумать о том, чтобы определить поля без инициализации: создать единственный конструктор, выполняющий общую инициализацию и заставить каждый конструктор явно вызвать общий конструктор.

## Конструкторы экземпляров и структуры (значимые типы)



## Конструкторы типов



## Методы перегруженных операторов



### Операторы и взаимодействие языков программирования 



### Особое мнение автора о правилах Microsoft, связанных с именами методов операторов



## Методы операторов преобразования



## Методы расширения



### Правила и рекомендации



### Расширение разных типов методами расширения



### Атрибут расширения



## Частичные методы



### Правила и рекомендации

