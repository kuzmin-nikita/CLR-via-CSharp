## Конструкторы экземпляров и классы (ссылочные типы)

Конструкторы - специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В таблице определений в метаданных отмечаются сочетанием .ctor (от _constructor_). При создании экземпляра ссылочного типа выделяется память для полей данных и инициализируются службеные поля (индекс блока синхронизации и ссылка на объект-тип), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта.

При конструировании объекта ссылочного типа выделяемая для него память обнуляется до вызова конструктора экземпляра: любые поля, не задаваемые конструктором явно, гарантировано содержат 0 ли `null`.

В отличие от других методов конструкторы экземпляров не наследуются: у класса есть только те конструкторы, которые определены в классе. Невозможность наследования означает, что к конструкторам невозможно применить [модификаторы наследования](https://github.com/kuzmin-nikita/CLR-via-CSharp/blob/main/chapters/Chapter6.md#модификаторы-наследования). Если определить класс без явно заданных конструкторов, компилятор создаст конструктор по умолчанию, который просто вызывает конструктор без параметров базового класса.

Для абстрактных классов компилятор создаёт конструктор с модификатором `protected`, иначе область видимости будет открытой. Если в базовом классе нет конструктора без параметров, производный класс должен явно вызывать конструктор базовго класса, иначе компилятор вернёт ошибку. Для статических классов компилятор не создаёт конструктор по умолчанию.

В типе можно определить несколько конструкторов, при этом сигнатуры и уровни доступа должны отличаться. В случае верифицируемого кода конструктор экземпляров должен вызвать конструктор базового класса до обращения к какому-либо из унаследованных от него полей. В конечном счёте всегда вызывается конструктор `System.Object`, который ниего не делает, а только возвращает управление, так как в `object` не определены поля.

В редких случаях экземпляр может создаваться без вызова конструктора. Например, метод `MemberwiseClone()` выделяет память, инициализирует служебные поля объекта, а потом копирует байты исходного объекта в новую область памяти. Кроме того, конструктор обычно не вызывается при десериализации.

Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут повлиять на создаваемый объект. Потому что если виртуальный метод переопределён в проивзодном типе, то реализация производного типа вызовется до того, как завершится инициализация всех полей в иерархии. В таких обстоятельствах последсьвия вызова непредсказуемы.

Если имеется несколько инициализируемых экземплярных полей и множество перегруженных конструкторов, стоит подумать о том, чтобы определить поля без инициализации: создать единственный конструктор, выполняющий общую инициализацию и заставить каждый конструктор явно вызвать общий конструктор.

## Конструкторы экземпляров и структуры (значимые типы)

Конструкторы значимых типов работают иначе. CLR всегда разрешает создание экземпляров значимых типов и этому ничто не может помешать. Поэтому по большому счёту конструкторы у значимого типа можно не определять. Фактически компиляторы не определяют для значимых типов конструкторы по умолчанию.

```csharp
internal struct Point
{
  public Int32 m_x, m_y;
}

internal sealed class Rectangle
{
  public Point m_topLeft, m_bottomRight;
}
```

Для создания объекта ссылочного типа надо использовать оператор `new()` с указанием конструктора. В этом случае вызывается конструктор по умолчанию. Память, выделенная для объекта ссылочного типа включает место для двух кэземпляров значимого типа. Из соображений производительности CLR не пытается вызвать конструктор для каждого экземпляра значимого типа, содержащегося в объекте ссылочного типа. Поля значимого типа инициализируются нулями/`null`.

CLR позволяет определять конструкторы для значимых типов, но они выполняются лишь при наличии кода, явно вызывающего один из них.

Конструктор экземпляра значимого типа выполняется только при явном вызове, так что если конструктор ссылочного типа не инициализировал поля значимого типа вызовом с помощью оператора `new()` конструкторам значимого типа, то они поля значимого типа будут содержать значения по умолчанию.

Если значимый тип уже определён, то определяется конструктор, по умолчанию не имеющий параметров.

Фактически большинство компиляторов никогда не генерирует автоматически код для вызова конструктора по умолчанию для значимого типа даже при наличии конструктора без параметров. Для исполнения конструктора значимого типа без параметров, разработчик должен явно его вызвать. Однако C# не позволяет даже создать конструктор без параметров, и выдаст ошибку компиляции. Это сделано специально, чтобы не вводить разработчиков в заблуждение.

В поля значимого типа обязательно заносятся знаения 0 или `null`, если значимый тип вложен в объект ссылочного типа. Однако сказать такое про значимый тип, хранящийся в стеке, нельзя. Так как код верифицируемый, компилятор гарантирует, что поля значимого типа обнулятся или заполнятся каким-то значением, так что исключений возникнуть не должно.

C# не допускает конструктором без параметров для значимых типов, но CLR это разрешает, так что такую структуру можно написать на IL. G о этой же причине нельзя использовать инициализаторы полей (они разворачиваются в конструктор без параметров).

При наличии конструктора с параметрами, он должен инициализировать все поля. Это можно обойти, если прописать в конструкторе `this = new SomeValueType();`, а затем инициализировать необходимые поля. В ссылочных типах указатель `this` может быть использован только для чтения.

## Конструкторы типов



## Методы перегруженных операторов



### Операторы и взаимодействие языков программирования 



### Особое мнение автора о правилах Microsoft, связанных с именами методов операторов



## Методы операторов преобразования



## Методы расширения



### Правила и рекомендации



### Расширение разных типов методами расширения



### Атрибут расширения



## Частичные методы



### Правила и рекомендации

