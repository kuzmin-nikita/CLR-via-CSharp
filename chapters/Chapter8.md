## Конструкторы экземпляров и классы (ссылочные типы)

Конструкторы - специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В таблице определений в метаданных отмечаются сочетанием .ctor (от _constructor_). При создании экземпляра ссылочного типа выделяется память для полей данных и инициализируются службеные поля (индекс блока синхронизации и ссылка на объект-тип), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта.

При конструировании объекта ссылочного типа выделяемая для него память обнуляется до вызова конструктора экземпляра: любые поля, не задаваемые конструктором явно, гарантировано содержат 0 ли `null`.

В отличие от других методов конструкторы экземпляров не наследуются: у класса есть только те конструкторы, которые определены в классе. Невозможность наследования означает, что к конструкторам невозможно применить [модификаторы наследования](https://github.com/kuzmin-nikita/CLR-via-CSharp/blob/main/chapters/Chapter6.md#модификаторы-наследования). Если определить класс без явно заданных конструкторов, компилятор создаст конструктор по умолчанию, который просто вызывает конструктор без параметров базового класса.

Для абстрактных классов компилятор создаёт конструктор с модификатором `protected`, иначе область видимости будет открытой. Если в базовом классе нет конструктора без параметров, производный класс должен явно вызывать конструктор базовго класса, иначе компилятор вернёт ошибку. Для статических классов компилятор не создаёт конструктор по умолчанию.

В типе можно определить несколько конструкторов, при этом сигнатуры и уровни доступа должны отличаться. В случае верифицируемого кода конструктор экземпляров должен вызвать конструктор базового класса до обращения к какому-либо из унаследованных от него полей. В конечном счёте всегда вызывается конструктор `System.Object`, который ниего не делает, а только возвращает управление, так как в `object` не определены поля.

В редких случаях экземпляр может создаваться без вызова конструктора. Например, метод `MemberwiseClone()` выделяет память, инициализирует служебные поля объекта, а потом копирует байты исходного объекта в новую область памяти. Кроме того, конструктор обычно не вызывается при десериализации.

Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут повлиять на создаваемый объект. Потому что если виртуальный метод переопределён в проивзодном типе, то реализация производного типа вызовется до того, как завершится инициализация всех полей в иерархии. В таких обстоятельствах последсьвия вызова непредсказуемы.

Если имеется несколько инициализируемых экземплярных полей и множество перегруженных конструкторов, стоит подумать о том, чтобы определить поля без инициализации: создать единственный конструктор, выполняющий общую инициализацию и заставить каждый конструктор явно вызвать общий конструктор.

## Конструкторы экземпляров и структуры (значимые типы)

Конструкторы значимых типов работают иначе. CLR всегда разрешает создание экземпляров значимых типов и этому ничто не может помешать. Поэтому по большому счёту конструкторы у значимого типа можно не определять. Фактически компиляторы не определяют для значимых типов конструкторы по умолчанию. 

```csharp
internal struct Point
{
  public Int32 m_x, m_y;
}

internal sealed class Rectangle
{
  public Point m_topLeft, m_bottomRight;
}
```

Для создания объекта ссылочного типа надо использовать оператор `new()` с указанием конструктора. В этом случае вызывается конструктор по умолчанию. Память, выделенная для объекта ссылочного типа включает место для двух кэземпляров значимого типа. Из соображений производительности CLR не пытается вызвать конструктор для каждого экземпляра значимого типа, содержащегося в объекте ссылочного типа. Поля значимого типа инициализируются нулями/`null`.

CLR позволяет определять конструкторы для значимых типов, но они выполняются лишь при наличии кода, явно вызывающего один из них.

Конструктор экземпляра значимого типа выполняется только при явном вызове, так что если конструктор ссылочного типа не инициализировал поля значимого типа вызовом с помощью оператора `new()` конструкторам значимого типа, то они поля значимого типа будут содержать значения по умолчанию.

Если значимый тип уже определён, то определяется конструктор, по умолчанию не имеющий параметров.

Фактически большинство компиляторов никогда не генерирует автоматически код для вызова конструктора по умолчанию для значимого типа даже при наличии конструктора без параметров. Для исполнения конструктора значимого типа без параметров, разработчик должен явно его вызвать. Однако C# не позволяет даже создать конструктор без параметров, и выдаст ошибку компиляции. Это сделано специально, чтобы не вводить разработчиков в заблуждение.

В поля значимого типа обязательно заносятся знаения 0 или `null`, если значимый тип вложен в объект ссылочного типа. Однако сказать такое про значимый тип, хранящийся в стеке, нельзя. Так как код верифицируемый, компилятор гарантирует, что поля значимого типа обнулятся или заполнятся каким-то значением, так что исключений возникнуть не должно.

C# не допускает конструктором без параметров для значимых типов, но CLR это разрешает, так что такую структуру можно написать на IL. G о этой же причине нельзя использовать инициализаторы полей (они разворачиваются в конструктор без параметров).

При наличии конструктора с параметрами, он должен инициализировать все поля. Это можно обойти, если прописать в конструкторе `this = new SomeValueType();`, а затем инициализировать необходимые поля. В ссылочных типах указатель `this` может быть использован только для чтения.

## Конструкторы типов

Помимо экземплярных конструкторов, CLR также поддерживает конструкторы типов (статические конструкторы / конструкторы классов / инициализаторы типов). Конструкторы типов можно применять в интерфейсах (не в C#), ссылочным и значимым типам. Данные конструкторы определяют первоначальное состояние объекта-типа. По умолчанию у типа не определено конструктора. У типа не может быть более одного окнструктора. У конструктора типа не должно быть параметров.

Конструкторы типов объвляют так же, как и экземплярные, однако их помечают ключевым словом `static`, а также они всегда должны быть закрытыми (по умолчанию) и модификаторы доступа к ним не применимы.

Хотя конструктор значимого типа определить можно, этого не следует делать, потому что CLR иногда может не вызвать его.

При компиляции метода JIT-компилятор обнаруживает типы, на которые есть ссылки из кода. Если в каком-то типе есть конструктор, то JIT-компилятор проверяет, был ли он исполнен в текущем домене.

Затем посел JIT-компиляции метода начинается выполнение потока. В реальности потоков можнт быть несколько. В этом случае CLRстарается гарантировать, чтобы конструктор типа выполнялся единожды в каждом домене. Для этого при вызове конструктора типа вызываюий поток получает исключающую блокировку. Это означает, что при попытке вызвать конструктор типа только один поток получит эту возможность, остальные будут заблокированы. Первый поток выполнит код статического конструктора, после чего проснутся остальные потоки и проверят, был ли вызван данный конструктор. Потоки не станут вызывать конструктор, а просто вернут управление.

Благодаря этой особенности конструктор типа лучше всего подходит для инициализации объектов-одиночек.

В рамках одного потока возможно ситуация, когда конструкторы типа ссылаются друг на друга. Даже в этом случае CLR постарается корректно разрешить эту ситуацию, однако так как за вызов подобных конструкторов отвечает CLR, то не стоит вызывать их явно. 

Наконец, если конструктор типа выбрасывает исключение, тип счиатся непригодным и при попытке обращения к любому полю этого типа возникает исключение `System.TypeInitializationException`.

Статический конструктор может инициализировать только статические поля. C# предлагает простой синтаксис через инициализатор.

C# не разрешает использовать синтаксис инициализации полей в значимых типах. Однако в значимых типах по-прежнему можно использовать инициализацию статических полей.

В таблице определений типов метод-конструктор типа называется .cctor (от _class constructor_).

При наличии в классе инициализации статического поля и статического конструктора код инициализации как бы вставляется в конструктор перед всеми его операциями.

Несмотря на то, что для типов не существует статических методов `Finalize()`, выгрузить тип из домена можно, зарегистрироваа колбэк метод для события `DomainUnload` типа `System.AppDomain`. Хотя это и не имеет особого смысла, так как GC освобождает всю занятую память при закрытии домена.

## Методы перегруженных операторов

В некоторых языках тип может определять, как операторы должны манипулировать его экземплярами. CLR ничего не известно о перегрузке операторов, потому что среда даже не знает, что такое оператор. Смысл операторов и код, который должен быть сгенерирован, определяется языком программирования. 

Хоть CLR ничего не знает об операторах, она указывает, как языки программирования должны предоставлять доступ к перегруженным операторам, а далее каждый язык сам решает, будет ли он использовать эту возможность. С точки зрения CLR перегруженные операторы представляют из себя просто методы.

Спецификация CLR требует, чтобы перегруженные операторы были статическими и открытыми. Кроме этого сам C# требует, чтобы тип одного из параметров совпадал с типом, в котором определна перегрузка операторов. Это помогает компилятору в разумное время находить кандидатуры операторных методов для привязки.

В книге можно найти примеры доступных для перегрузки операторов (см. стр. 227-228).

Для примитивных типов операторы не перегружены, а реализованы через сгенерированные IL-команды. Это позволяет ускорить быстродействие при применении операторов к примитивным типам (которые применяются чаще всего).

### Операторы и взаимодействие языков программирования 



### Особое мнение автора о правилах Microsoft, связанных с именами методов операторов



## Методы операторов преобразования



## Методы расширения



### Правила и рекомендации



### Расширение разных типов методами расширения



### Атрибут расширения



## Частичные методы



### Правила и рекомендации

