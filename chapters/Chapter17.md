## Знакомство с делегатами

В .NET функции обратного вызова играют не менее важную роль, чем при неуправляемом программировании. Однако данная платформа предлагает в распоряжение разработчика _делешаты_ (deegates) - механизм, безопасный по отношению к типами.

```csharp 
internal delegate void Feedback(Int32 value);
```

Объявление делегата задаёт сигнатуру метода обратного вызова. Далее можно создавать экземпляры данного делегата, передавая в конструктор имена методов с той же сигнатурой. Также можно вызывать делегаты внутри других методов.

## Обратный вызов статических методов

При передаче в метод параметром создаётся делегат, который выступает оболочкой для метода обратного вызова, позволяя выполнить его вызов. Делается это через конструктор делегата `Feedback`. Возвращённая оператором `new` ссылка передаётся в качестве аргумента метода, который будет вызывать статический метод.

Если код одного типа вызывает посредством делегата закрытый член другого типа, проблем с безопасностью или уровнем доступа не возникает, если делегат создан в коде, имеющем нужный уровень доступа.

При создании делегата компилятор убеждается в том, что сигнатуры передаваемых в  конструктор методов совместимы с сигнатурой делеагата. В противном случае компилятор выбросит ошибку.

Как C#, так и CLR поддерживают ковариантность и контравариантность ссылочных типов при привязке метода к делегату. _Ковариантность_ означает, что метод может возвращать тип, производный от типа, возвращаемого делегатом. _Контравариантность_ означает, что метод может принимать тип, являющийся базовым для типа параметра делеагата (прим. _Всё так же, как и в обобщениях_). Стоит заметить, что ковариантность и контравариантность поддерживаются только для ссылочных типов, потому что при использовании значимых типов или `void` структура памяти меняется, когда для ссылочных типов всегда остаётся указатель. Благо, подобные попытки будут пресекаться компилятором.

## Обратный вызов экземплярных методов

Вызов экземплярных методов схож с вызовом статических методов. Однако при передаче метода в конструктор делегата необходимо создать экземпляр типа и передать метод с указанием экземпляра. В таком случае при обратном вызове метода адрес только что созданного объекта будет передан экземплярному методу в качестве неявного аргумента `this`. Это означчает наличие у объекта состояния, которое может использоваться по врмя выполнения метода обратного вызова. 

## Тонкости использования делегатов



## Обратный вызов нескольких методов (цепочки делегатов)



### Поддержка цепочек делегатов C# 



### Дополнительне средства управления цепочками делегатов



## Обобщённые делегаты



## Упрощённый синтаксис работы с делегатами



### Упрощение 1: не создаём объект делегата 



### Упрощение 2: не определяем метод обратного вызова



### Упрощение 3: не создаём обёртку для локальных переменных для передачи их методу обратного вызова



## Делегаты и отражение

