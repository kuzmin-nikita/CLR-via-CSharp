## Знакомство с делегатами

В .NET функции обратного вызова играют не менее важную роль, чем при неуправляемом программировании. Однако данная платформа предлагает в распоряжение разработчика _делешаты_ (deegates) - механизм, безопасный по отношению к типами.

```csharp 
internal delegate void Feedback(Int32 value);
```

Объявление делегата задаёт сигнатуру метода обратного вызова. Далее можно создавать экземпляры данного делегата, передавая в конструктор имена методов с той же сигнатурой. Также можно вызывать делегаты внутри других методов.

## Обратный вызов статических методов

При передаче в метод параметром создаётся делегат, который выступает оболочкой для метода обратного вызова, позволяя выполнить его вызов. Делается это через конструктор делегата `Feedback`. Возвращённая оператором `new` ссылка передаётся в качестве аргумента метода, который будет вызывать статический метод.

Если код одного типа вызывает посредством делегата закрытый член другого типа, проблем с безопасностью или уровнем доступа не возникает, если делегат создан в коде, имеющем нужный уровень доступа.

При создании делегата компилятор убеждается в том, что сигнатуры передаваемых в  конструктор методов совместимы с сигнатурой делеагата. В противном случае компилятор выбросит ошибку.

Как C#, так и CLR поддерживают ковариантность и контравариантность ссылочных типов при привязке метода к делегату. _Ковариантность_ означает, что метод может возвращать тип, производный от типа, возвращаемого делегатом. _Контравариантность_ означает, что метод может принимать тип, являющийся базовым для типа параметра делеагата (прим. _Всё так же, как и в обобщениях_). Стоит заметить, что ковариантность и контравариантность поддерживаются только для ссылочных типов, потому что при использовании значимых типов или `void` структура памяти меняется, когда для ссылочных типов всегда остаётся указатель. Благо, подобные попытки будут пресекаться компилятором.

## Обратный вызов экземплярных методов

Вызов экземплярных методов схож с вызовом статических методов. Однако при передаче метода в конструктор делегата необходимо создать экземпляр типа и передать метод с указанием экземпляра. В таком случае при обратном вызове метода адрес только что созданного объекта будет передан экземплярному методу в качестве неявного аргумента `this`. Это означчает наличие у объекта состояния, которое может использоваться по врмя выполнения метода обратного вызова. 

## Тонкости использования делегатов

На первый взгляд работать с делегатами легко: определяется делегат с помощью ключевого слова `delegate`, с помощью оператора `new` создаются экземпляры, а для обратного вызова служит знакомый синтаксис (но используется не имя метода, а параменная, указывающая на делегат). 

На самом деле всё обстоит сложнее, потому что часть сложности скрывается за работой компиляторов и CLR. По факту определение делегата:

```csharp 
internal delegate void Feedback(Int32 value);
```

разворачивается компилятором в полное определение класса (все типы делегатов являются производными от `System.MulticastDelegate`):

```csharp 
internal class Feedback : System.MulticastDelegate
{
  // Конструктор
  public Feedback(Object object, IntPtr method);

  // Метод, прототип которого задан в исходном тексте
  public virtual void Invoke(Int32 value);

  // Методы, обеспечивающие асинхронный обратный вызов
  public virtual IAsyncResult BeginInvoke(Int32 value, AsyncCallback callback, Object object);
  public virtual void EndInvoke(IAsyncResult result);
}
```

В основном используются только конструктор и метод `Invoke()`. Методы `BeginInvoke()` и `EndInvoke()` относятся к модели асинхронного программирования .NET Frmework, которая признана устаревшей и заменена асинхронными операциями.

Класс `System.MulticastDelegate` является производным от `System.Delegate`, который в свою очередь наследуется от `System.Object`. Два класса делегатов появились исторически. Однако иногда приходится работать и с делегатами, реализующими методы `System.Delegate.Combine()` и `System.Delegate.Remove()`. Этим методам всегда можно передавать определяемый разработчиком делегат, так как они определны в базовом типе.

Класс делегата может быть закрытым и открытым. Ещё следует помнить, что делегаты можно обхявлять как внутри класса, так и в глобальной области видимости. Ниже описаны три самых важных поля `MulticastDelegate`:

| Поле              | Тип             | Описание                                                                                                                          |
|-------------------|-----------------|-----------------------------------------------------------------------------------------------------------------------------------|
| `_target`         | `System.Object` | Поле указывает на значение, которое следует передать параметру `this` экземплярного метода (для статических методов будет `null`) |
| `_methodPtr`      | `System.IntPtr` | Внутреннее целочисленное значение, используемое CLR для идентификации метода обратного вызова                                     |
| `_invocationList` | `System.Object` | Обычно `null`, но может ссылаться на массив делегатов при построении из них цепочки                                               |

В конструктор делегата передаётся ссылка на объект и указатель на метод (получаемый из маркеров метаданных `MethodDef` или `MethodRef`). Таким образом, любой делегат - всего лишь обёртка для метода и обрабатываемого этим методом объекта.

Вызывать делегат можно как через указании имени делегата с передачей аргументов, так и через явный вызов метода `Invoke()`. Вызывая этот метод, он испоьзует закрытые поля `_target` и `_methodPtr` для вызова желаемого метода на заданном объекте.

## Обратный вызов нескольких методов (цепочки делегатов)



### Поддержка цепочек делегатов C# 



### Дополнительне средства управления цепочками делегатов



## Обобщённые делегаты



## Упрощённый синтаксис работы с делегатами



### Упрощение 1: не создаём объект делегата 



### Упрощение 2: не определяем метод обратного вызова



### Упрощение 3: не создаём обёртку для локальных переменных для передачи их методу обратного вызова



## Делегаты и отражение

