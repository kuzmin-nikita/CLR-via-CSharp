При отсуствии конкуренции потоков гибридные конструкции дают даже большую производительность, чем простейшие конструкции пользовательского режима. 

## Простая гибридная блокировка

В книге приводится пример простой гибридной блокировки на основе Interlocked-конструкции и AutoResetEvent.

## Зацикливание, владение потоком и рекурсия

Так как пееходы в ядро сильно снижают производительность, а потоки остаются запертыми короткое время, общую производительность можно повысить, заставив поток перед переходом в режим ядра на некоторое время зациклиться в пользовательском режиме. Если в это время блокирование, которого ждёт поток, станет возможным, переход в режим ядра не понадобится.

Некоторые варианты блокирования налагают ограничение, при котором получить право на блокировку может только поток, снимающий блокировку. В книге приводится ример гибридного блокирования, предполагающее одновременно ацикливание, владение потоком и рекурсию.

## Гибридные конструкции в FCL 

В FCL существует множество гибридных конструкций, которые призваны удержать потоки в пользовательском режиме, что повышает производительность.

### Классы ManualResetEventSlim и SemaphoreSlim

Классы ManualResetEventSlim и SemaphoreSlim функционируют точно так же, как их аналоги режима ядра, отличаясь только закцикливанием в пользовательском режиме. Они не создают конструкций режима ядра до возникновения конкуренции.

### Класс Monitor и блоки синхронизации

Самой популярной гибридной конструкцией является класс `Monitor`, обеспечиващий взаимоисключающее блокирование, владение потоком и рекурсией. Данная конструкция используется чаще других, так как является одной из самых старых. Для её поддержки в C# даже есть специальное ключевое слово, с ней по умолчанию умеет работать JIT-компилятор, а CLR пользуется ей от имени приложения. Однакол работать с ней не просто, а получить некорректный код очень легко. 

С каждым объектом в куче связан _блок синхронизации_ (sync block). Этот блок содержит поля для объекта ядра, идентификатора потока-владельца, счётчика рекурсии и счётчика ожидающих потоков. Класс монитор является статическим и его методы принимают ссылки на любой объект из кучи. Управление полями эти методы осуществляют в блоке синхронизации заданного объекта.

Привязка блока синхронизвции к каждому объекту в куче является очень расточительноый, так как большинство объектов никогда не пользуются этим блоком. Для снижения потребления памяти, разработчики CLR примении более эффективный вариант реализации. Во время инициализации CLR выделяется массив блоков синхронизации. При создании объекта в куче инициализируется _индекс блока синхронизации_ (sync block index), то есть индекс в массиве блоков синхронизации.

В момент конструирования объекта этому индексу присваивается -1. Затем при вызове метода `Monitor.Enter()` CLR обнаруживает свободный блок синхронизации и присваивает ссылку на него объекту. Метод `Exit()` проверяет наличие потоков, ожидающих блока синхронизации. Если таких потоков не обнаруживается, метод возвращает индексу значение -1, освобождая блоки синхронизации. Массив блоков синхронизации может быть увеличен, если в какой-то момент их станет недостаточно.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/1a842cc9-c4c0-45cb-b464-0001cb3a845b)

В книге приводится пример корректного использования `Monitor`.

Так как разработчики привыкли устанавливать и снимать блокировку в одном и том же методе, в C# появился упрощённый снтаксис для этого:

```csharp 
private void SomeMethod()
{
  lock (this)
  {
    // Этот код имеет эксклюзивный доступ к данным...
  }
}
```

Что эквивалентно:

```csharp
private void SomeMethod()
{
  Boolean lockTaken = false;

  try
  {
    // Исклюение (например, ThreadAbortException) может здесь появиться
    Monitor.Enter(this, ref lockTaken);
    // Этот код имеет монопольный доступ к данным...
  }
  finally
  {
    if (lockTaken)
      Monitor.Exit(this);
  }
}
```

Это приводит к тому, что снятая в блоке `finally` блокировка (в ситуации, когда в блоке `try` повреждаются данные), поволит работать с повреждёнными данными другому потоку.

### Класс ReaderWriterLockSlim

Если данные, которые читаются потоками, защищены взаимоисключающей блокировкой, то при попытке одновременного доступа нескольких потоков работу продолжит только один, а остальные блокируются, что ухудшает масштабируемость и снижает производительность. Хотя в случае одновременного чтение необходимости в блокировке нет, а вот при попытке записи требуется монопольный доступ. Конструкция [`ReaderWriteLockSlim`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim?view=net-8.0) призвана решить проблему, управляя потоками следующим образом:
- Если один поток осуществляет запись, все остальные потоки блокируются.
- Если один поток читает, все остальные потоки продолжают работать; блокируются только те, которые ждут доступа на запись.
- После завершения рыботы записывающего птока разблокируется либо один поток на запись, либо все читающий поток. При отсуствии заблокированных потоков блокировку получит следующий поток, которому это потребуется.
- После завершения всех читающих потоков, разблокируется записывающий поток. При отсуствии заблокированных потоков блокировку получит следующий поток, которому это потребуется.

### Класс OneManyLock

Рихтер создал собственную констркцию, которая работает быстрее, чем `ReaderWriteLockSlim`. Эта конструкция называется `OneManyLock`, так как она предоставляет доступ либо одному пишущему, либо многим читающим потокам. Подробнее в книге.

### Класс CountdownEvent

[`System.Threading.CountdownEvent`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.countdownevent?view=net-8.0) построен на основе `ManualResetEventSlim` и блокирует поток до достижения внутренним сётчиком 0. Поведение этой конструкции диаметрально противоположно семафору.

### Класс Barrier

[`System.Threading.Barrier`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.barrier?view=net-8.0) была создана для решения крайне редко возникающей проблемы, так что ею вряд ли придётся пользоваться. Она управляет группами параллельно выполняющихся потоков, обеспечивая одновременное прохождение ими всех фаз алгоритма.

### Выводы по гибридным конструкциям

Стоит по возможности избегать кода, блокирующего потоки. При асинхронных вычислениях или операциях ввода-вывода стоит передавать данные от одного потока другому так, чтобы исключить попытку олновременного доступа. Если это невозможно, сьтоит использовать `Volatile` или `Interlocked`. Однако они подходят только для работы с простыми типами.

Две причины для блокирования потоков:
- **Упрощение модели программирования.** Блокируя поток и жертвуя ресурсами, разработчик получает возможность писать код последовательно, без методов обратного вызова. Асинхронные функции C# предоставляют упрощённую модель программирования без необходимости блокировать потоки.
- **Поток имеет определённое назначение.**

Чтобы избежать блокировки потоков, не стоит мысленно связывать их с конкретными операциями. Потоки являются слишком ценным ресурсом, чтобы ограничивать их назначение. Стоит использовать пул потоков для возмоности потокам решать разные задачи.

При блокировки для снихронизации потоков из разных доменов стоит использовать конструкции режима ядра. Стоит стараться избешать рекурсиивных блокировок, так как они снижают производительность. Кроме того, стоит стараться не снимать блокировку в блоке `finally`, так как можно получить повреждённые данные.

В конечном счёте, для вычислительных операций или операций ввода-вывода стоит использовать асинхронные операции, так как они используют преимущества пула потоков.

## Блокировка с двойной проверкой



## Паттерн условной перменной



## Асинхронная синхронизация



## Классы коллекций для параллельного доступа

