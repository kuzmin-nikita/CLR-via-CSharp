При отсуствии конкуренции потоков гибридные конструкции дают даже большую производительность, чем простейшие конструкции пользовательского режима. 

## Простая гибридная блокировка

В книге приводится пример простой гибридной блокировки на основе Interlocked-конструкции и AutoResetEvent.

## Зацикливание, владение потоком и рекурсия

Так как пееходы в ядро сильно снижают производительность, а потоки остаются запертыми короткое время, общую производительность можно повысить, заставив поток перед переходом в режим ядра на некоторое время зациклиться в пользовательском режиме. Если в это время блокирование, которого ждёт поток, станет возможным, переход в режим ядра не понадобится.

Некоторые варианты блокирования налагают ограничение, при котором получить право на блокировку может только поток, снимающий блокировку. В книге приводится ример гибридного блокирования, предполагающее одновременно ацикливание, владение потоком и рекурсию.

## Гибридные конструкции в FCL 

В FCL существует множество гибридных конструкций, которые призваны удержать потоки в пользовательском режиме, что повышает производительность.

### Классы ManualResetEventSlim и SemaphoreSlim

Классы ManualResetEventSlim и SemaphoreSlim функционируют точно так же, как их аналоги режима ядра, отличаясь только закцикливанием в пользовательском режиме. Они не создают конструкций режима ядра до возникновения конкуренции.

### Класс Monitor и блоки синхронизации

Самой популярной гибридной конструкцией является класс `Monitor`, обеспечиващий взаимоисключающее блокирование, владение потоком и рекурсией. Данная конструкция используется чаще других, так как является одной из самых старых. Для её поддержки в C# даже есть специальное ключевое слово, с ней по умолчанию умеет работать JIT-компилятор, а CLR пользуется ей от имени приложения. Однакол работать с ней не просто, а получить некорректный код очень легко. 

С каждым объектом в куче связан _блок синхронизации_ (sync block). Этот блок содержит поля для объекта ядра, идентификатора потока-владельца, счётчика рекурсии и счётчика ожидающих потоков. Класс монитор является статическим и его методы принимают ссылки на любой объект из кучи. Управление полями эти методы осуществляют в блоке синхронизации заданного объекта.

Привязка блока синхронизвции к каждому объекту в куче является очень расточительноый, так как большинство объектов никогда не пользуются этим блоком. Для снижения потребления памяти, разработчики CLR примении более эффективный вариант реализации. Во время инициализации CLR выделяется массив блоков синхронизации. При создании объекта в куче инициализируется _индекс блока синхронизации_ (sync block index), то есть индекс в массиве блоков синхронизации.

В момент конструирования объекта этому индексу присваивается -1. Затем при вызове метода `Monitor.Enter()` CLR обнаруживает свободный блок синхронизации и присваивает ссылку на него объекту. Метод `Exit()` проверяет наличие потоков, ожидающих блока синхронизации. Если таких потоков не обнаруживается, метод возвращает индексу значение -1, освобождая блоки синхронизации. Массив блоков синхронизации может быть увеличен, если в какой-то момент их станет недостаточно.

![image](https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/1a842cc9-c4c0-45cb-b464-0001cb3a845b)

В книге приводится пример корректного использования `Monitor`.

Так как разработчики привыкли устанавливать и снимать блокировку в одном и том же методе, в C# появился упрощённый снтаксис для этого:

```csharp 
private void SomeMethod()
{
  lock (this)
  {
    // Этот код имеет эксклюзивный доступ к данным...
  }
}
```

Что эквивалентно:

```csharp
private void SomeMethod()
{
  Boolean lockTaken = false;

  try
  {
    // Исклюение (например, ThreadAbortException) может здесь появиться
    Monitor.Enter(this, ref lockTaken);
    // Этот код имеет монопольный доступ к данным...
  }
  finally
  {
    if (lockTaken)
      Monitor.Exit(this);
  }
}
```

Это приводит к тому, что снятая в блоке `finally` блокировка (в ситуации, когда в блоке `try` повреждаются данные), поволит работать с повреждёнными данными другому потоку.

### Класс ReaderWriterLockSlim



### Класс OneManyLock



### Класс CountdownEvent



### Класс Barrier



### Выводы по гибридным конструкциям



## Блокировка с двойной проверкой



## Паттерн условной перменной



## Асинхронная синхронизация



## Классы коллекций для параллельного доступа

