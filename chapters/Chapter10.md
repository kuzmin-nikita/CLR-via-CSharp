## Свойства без параметров

Во многих типах определяется информация состояния, которую можно прочитать или изменить. Часто эта информация реализуется полями типа.

```csharp
public sealed class Person
{
	public Int32 Age;
}
```

Этот способ чтения и записи является очень распространённым. Однако автор считает, что такая реализация недопустима. Краеугольным камнем ООП является _инкапсуляция данных_. Инкапсуляция данных означает, что поля типа ни в коем случае нельзя открывать для общего доступа, иначе это может испортить сведения о состоянии объекта. Например, человеку можно выставить отрицательный возраст.

Есть и другие причины для инкапсуляции. Допустим, нужен доступ к полю, но так, чтобы обращение не нарушало безопасность потоков. Или, например, поле является логическим, и его значение представлено не байтами в памяти, а вычисляется по некоторому алгоритму.

Каждая из этих причин заставляет при разработке типов, во-первых, помечать все поля как закрытые, во-вторых, давать пользователю вашего типа возможность полечений и задания сведений о состоянии через специальные методы, преназначенные исключительно для этого. Методы, выполнящие функции оболочки доступа к полю, обычно называют _методами доступа_ (accessor). Методы доступа могут выполнять дополнительыне проверки, гарантируя, что сведения о состоянии объекта не будут искажены.

```csharp
public sealed class Person 
{
	private Int32 m_Age; // Поле стало закрытым

	public Int32 GetAge() 
	{
		return(m_Age);
	}
	
	public void SetAge(Int32 value) 
	{
		if (value < 0)
		{
			throw new ArgumentOutOfRangeException("value", value.ToString(), "The value must be greater than or equal to 0");
		}
	
		m_Age = value;
	}
}
```

Методы доступа предоставляют огромное преимущество инкапсуляции полей данных. С помощью них можно также легко сделать поля доступными только для чтения или записи - достаточно удалить один из методов.

Однако у инкапсуляции даннхы есть два недостатка: во-первых, из-за реализации дополнительных методов приходится писать более длинный код, во-вторых, вместо простой ссылки на имя поля пользователям типа приходится вызывать соответствующие методы.

Автор считает эти недостатки незначительными. Тем не менее CLR поддерживает механизм свойств, частично компенсирующих первый недостаток и полностью устранящий второй. 

```csharp
public sealed class Person 
{
	private Int32 m_Age;
 
	public Int32 Age 
	{
		get { return(m_Age); }
		set 
		{
			if (value < 0) // Ключевое слово value всегда идентифицирует новое значение
			{
				throw new ArgumentOutOfRangeException("value", value.ToString(), "The value must be greater than or equal to 0");
			}
			
			m_Age = value;
		}
	}
} 
```

Хоть свойства немного усложняют определение типа, доступ к полям типа извне становится куда более лаконичным.

Можно считать свойства умными полями, то есть полями с дополнитеьнй логикой. CLR поддерживает статически, жкземплярные, абстрактные и виртуальные свойства. Кроме того, свойства могут помечаться модификатором доступа и определяться в интерфейсах.

У каждого свойтсва есть имя и тип (но не `void`). Свойства нельзя перегружать, то есть делать несколько свойств с одинаковыми именами и разными типами. При определении свойств используют пару методов `get` и `set`, однако, опустив одно из них, можно получить поле только для записи или чтения соответственно. 

Методы `get` и `set` свойства обычно манипулируют закрытым полем, определённым в типе. Это поле называют _резурвным_ (backing field). Однако методам не приходится обращаться к резервному полю.

При определнии свойства компилятор генерирует и помещает в результирующий управляемый модель следующее:
- Метод `get` (только если определён соответствующий метод)
- Метод `set` (только если определён соответствующий метод)
- Определение свойства генерируется всегда

Компилятор автоматически генерирует имена этих методов, прибавляя префиксы `get_` и `set_`.

Поддержка свойств встроена в C#. Обнаружив код, пытаюсщийся получить или задать свойства, компилятор генерирует вызов соответствующего метода. Если язык не поддерживает свойства напрямую, то к ним всё равно можно обратиться посредством явного вызова метода, хоть такой код и выглядит менее элегантно.

### Автоматически реализуемые свойства

Если необходимо создать свойства для инкапсуляции резервных полей.ю то в C# есть упрощённый синтаксис, называемый автоматически реализуемыми свойствами (Automatically Implemented Properties, AIP).

Если объявить свойство без реализации методов доступа, то C# автоматически объявит поле закрытым, и компилятор автоматически реализует методы для правильного возвращения значения из поля и назначения значения полю. Преимущество автосвойства состоит в том, что если в последствии захочется изменить код методов доступа, то не придётся перекомпилировать исходный код.

Автор старается избегать автосвойств по нескольким причинам:
- Синтаксис объявения поля может включать инициализацию, таким образом, разработчик объявляет и инициализирует поле в одной строки. Автосвойства необходимо инициализировать во всех конструкторах. (прим. Возможность инициализации автосвойств появилась в C# 6)
- Механизм сериализации на этапе выполнения сохраняет имя поля в сериализованном потоке. Имя резерного поля для автосвойсвта определяется компилятором, и оно может меняться, сводя на нет возможности десериализации таких типов. Не стоит использовать автосвойства для типов, подлежащих сериализации и десериализации.
- Во время отладки нельзя установить точку останова в методах доступа. Точки можно устанавливать только в свойствах, которые разработчик описывает самостоятельно.

При использовании автосвойств свойства должны иметь уровень доступа для чтения и записи. Из-за того, что не известно имя автоматически генерируемого поля, программный код всегда должен обращаться к своству по имени. А если разработчик решит явно реализовать один из методов доступа, то придётся явно реализовать оба метода, при этом отказавшись от автосвойств. Механизм автосвойств работает слишком бескомпромисно.

### Осторожный подход к определению свойств

Автор был бы рад удалить поддержку свойств из .NET, потому что они порождают путаницу, по его меннию:
- Свойства могут быть доступны только для чтения или записи, в то время как поле всегда доступно для чтения и записи.
- Свойства, являясь методом, могут выдавать исключения, а при обращении к полям исключений не бывает.
- Свойства нельзя передавать в метод с ключевым словом `out`.
- Свойство-метод может выполняться довольно долго, в то время как обращение к полю происходит моментально. Часто свойства применяют для синхронизации потоков, но тогда поток может быть приостановлен на неопределённое время.
- При нескольких вызовах подряд свойство-метод может вернуть разные значения (например, `System.DateTime.Now`).
- Свойство-метод может попрождать видимые побочные эффекты, невозможные при доступе к полю.
- Свойству-методу может требоваться дополнительная память или ссылка на объект, не являющийся частью состояния объекта, поэтому изменение возвращаемого объекта никак не сказывается на исходном объекте.

Автор считает, что разработчики используют свойства намного чаще, чем следовало бы. Да, свойства предоставляют удобный синтаксис, но при это теряются проиизводительность и чаемость кода. (прим. _Я не согласен с автором. Может быть, действительно происходит потеря производительности, но синтаксис куда удобнее обычных полей._)

### Свойства и отладчик Visual Studio

...

### Инициализаторы объектов и коллекций 

Создание объекта с заданием некоторых открытых свойств (или полей) - чрезвычайно распостранённая операция. Для её упрощения в C# предусмотрен специальный синтаксис:

```csharp
Employee e = new Employee() { Name = "Jeff", Age = 45 };
```

Компилируется это всё так, как если бы сначала был создан объект через вызов конструктора по умолчанию, потом были бы инициализированы поля, и в конце полученный объект присваивался бы переменной. 

Реальная выгода от синтаксиса инициализатора в том, что можно применять к полученному объекту цепочные функции:

```csharp
String s = new Employee() { Name = "Jeff", Age = 45 }.ToString().ToUpper();
```

C# также позволяет опускать круглые скобки перед открывабщей фигурной, если разработчик хочет вызвать конструктор без параметров.

Если тип свойсвта реализует интерфейс IEnumerable или IEnumerable<T>, то свойство является коллекцией, а инициализация является дополняющей (а не заменяющей) операцией. Тогда код будет идентичен тому, как если бы сначала создалась коллекция, а потом элементы помещались бы туда по одному через метод `Add()`.

Если же тип реализует данные интерфейсы, но не имеет метода `Add()`, тогда коллекцию нельзя инициализировать.

### Анонимные типы

Механизм анонимных типов в C# позвоялет объявить кортежный тип при помощи простого синтаксиса. _Кортежный тип_ (tuple type) - тип, который содержит коллекцию свосйств, каким-то образом связанных друг с другом.

```csharp
var o1 = new { Name = "Jeff", Year = 1964 };
```

Здесь создаётся анонимный тип, потому что не был определён тип имени после `new`. Таким образом компилятор автоматически создаёт имя типа, но не сообщает его (поэтому тип и называется анонимным). В таком случае всегда используется неявная типизация с применением клчевого слова `var`.

При использовании анонимного типа, компилятор определяет тип каждого выражения, создаёт закрытые поля этих типов, для каждого поля созда1т открытые свойства только для чтения и для всех этих выражений созлаёт конструктор.  Код конструктора инициализирует закрытые поля только для чтения путём вычисления результирующих значений. В дополнение к этому, компилятор переопределяет методы `Equals()`, `GetHashCode()` и `ToString()`.

Компилятор генерирует первые два метода, чтобы экземпляр анонимного типа могли размещаться в хеш-таблица. Неизменяемые свойства помогают защитить хеш-код объекта от изменений, так как это может помешать нахождению объекта в таблице. Последний же метод компилятор генерирует для упрощения отладки. 

Также свойства анонимного типа можно инициализировать переменными или их свойствами, без явного указания имени. Тогда имя и тип свойства анонимного типа будут совпадать с именем и типом выражения.

Компилятор очень разумено выявляет анонимный тип. Если он видит, что определено множество анонимных типов с идентичными структурами, то он создаёт одно определение этого типа и множество его экземпляров. Под одинаковой структурой подразумевается одинаковые типы, имена и порядок следования свойств.

Раз две переменные относятся к одинаковому типу, то их можно сравнивать, а также присваивать ссыку на один объект переменной другого объекта.

Раз эти типы идентичны, то можно создать массив из анонимных типов.

Анонимные типы обычно используются с технологией языка интегрированных запросов (Language INtegrated Query, LINQ), когда в результате выполнения запроса создаётся коллекция объектов, относящихся к одному анонимному типу.

Экземпляры анонимного типа не должны выходить за пределы метода. В прототипе метода не может содержаться параметр анонимного типа, так как задать его невозможно. По тому же принципу метод не может возвращать анонимный тип. Хотя экземпляры анонимного типа можно преобразовать к `object`, выполнить обратное преобразование нельзя, потмоу что имя анонимного типа на этапе компиляции неизвестно. Для передачи кортежноого типа следует использовать `System.Tuple` (прим. _Или `dynamic`, хотя лучше этого не делать_).

### Тип System.Tuple

В пространстве имён `System` определено несколько обобщённых кортежных типов, которые отличаются количеством обобщённых параметров.

Как и объекты анонимного типа, объект `Tuple` оздаётся один раз и остаётся неизменным. Кортеж позволяет использовать все базовые методы, а также методы сравнения (через реализацию в типе кортежа соответствующих интерфейсов).

Важно, чтобы производитель и потребитель кортежа имели чёткое представление о том, что возвращается в элементах кортежа. С анонимными типами свойства получают действительные имена на основании программного кода, инициализирующего их. Для кортежа имена назначаются автоматически и не имеют настоящего смысла, что ухудшает читабельность и сопровождение, так что появляется необходимость добавлять комментарии.

Чтобы создать кортеж с более чем восьмью лементами, стоит использовать вложенный кортеж.

Кроме анонимных и кортежных типов, стоит присмотреться к классу `System.Dynamic.ExpandoObject`. Он не обладает безопасностью типов, зато предоставляет удобный синтаксис. 

## Свойства с параметрами



### Выбор главного свойства с параметрами



## Производительность при вызове методов доступа 



## Доступность метода доступа свойств



## Обобщённые методы доступа свойств

