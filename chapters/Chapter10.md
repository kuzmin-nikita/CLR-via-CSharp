## Свойства без параметров

Во многих типах определяется информация состояния, которую можно прочитать или изменить. Часто эта информация реализуется полями типа.

```csharp
public sealed class Person
{
	public Int32 Age;
}
```

Этот способ чтения и записи является очень распространённым. Однако автор считает, что такая реализация недопустима. Краеугольным камнем ООП является _инкапсуляция данных_. Инкапсуляция данных означает, что поля типа ни в коем случае нельзя открывать для общего доступа, иначе это может испортить сведения о состоянии объекта. Например, человеку можно выставить отрицательный возраст.

Есть и другие причины для инкапсуляции. Допустим, нужен доступ к полю, но так, чтобы обращение не нарушало безопасность потоков. Или, например, поле является логическим, и его значение представлено не байтами в памяти, а вычисляется по некоторому алгоритму.

Каждая из этих причин заставляет при разработке типов, во-первых, помечать все поля как закрытые, во-вторых, давать пользователю вашего типа возможность получения и задания сведений о состоянии через специальные методы, переназначенные исключительно для этого. Методы, выполняющие функции оболочки доступа к полю, обычно называют _методами доступа_ (accessor). Методы доступа могут выполнять дополнительные проверки, гарантируя, что сведения о состоянии объекта не будут искажены.

```csharp
public sealed class Person 
{
	private Int32 m_Age; // Поле стало закрытым

	public Int32 GetAge() 
	{
		return(m_Age);
	}
	
	public void SetAge(Int32 value) 
	{
		if (value < 0)
		{
			throw new ArgumentOutOfRangeException("value", value.ToString(), "The value must be greater than or equal to 0");
		}
	
		m_Age = value;
	}
}
```

Методы доступа предоставляют огромное преимущество инкапсуляции полей данных. С помощью них можно также легко сделать поля доступными только для чтения или записи - достаточно удалить один из методов.

Однако у инкапсуляции данных есть два недостатка: во-первых, из-за реализации дополнительных методов приходится писать более длинный код, во-вторых, вместо простой ссылки на имя поля пользователям типа приходится вызывать соответствующие методы.

Автор считает эти недостатки незначительными. Тем не менее CLR поддерживает механизм свойств, частично компенсирующих первый недостаток и полностью устраняющий второй. 

```csharp
public sealed class Person 
{
	private Int32 m_Age;
 
	public Int32 Age 
	{
		get { return(m_Age); }
		set 
		{
			if (value < 0) // Ключевое слово value всегда идентифицирует новое значение
			{
				throw new ArgumentOutOfRangeException("value", value.ToString(), "The value must be greater than or equal to 0");
			}
			
			m_Age = value;
		}
	}
} 
```

Хоть свойства немного усложняют определение типа, доступ к полям типа извне становится куда более лаконичным.

Можно считать свойства умными полями, то есть полями с дополнительной логикой. CLR поддерживает статически, экземплярные, абстрактные и виртуальные свойства. Кроме того, свойства могут помечаться модификатором доступа и определяться в интерфейсах.

У каждого свойства есть имя и тип (но не `void`). Свойства нельзя перегружать, то есть делать несколько свойств с одинаковыми именами и разными типами. При определении свойств используют пару методов `get` и `set`, однако, опустив одно из них, можно получить поле только для записи или чтения соответственно. 

Методы `get` и `set` свойства обычно манипулируют закрытым полем, определённым в типе. Это поле называют _резервным_ (backing field). Однако методам не приходится обращаться к резервному полю.

При определении свойства компилятор генерирует и помещает в результирующий управляемый модель следующее:
- Метод `get` (только если определён соответствующий метод)
- Метод `set` (только если определён соответствующий метод)
- Определение свойства генерируется всегда

Компилятор автоматически генерирует имена этих методов, прибавляя префиксы `get_` и `set_`.

Поддержка свойств встроена в C#. Обнаружив код, пытающийся получить или задать свойства, компилятор генерирует вызов соответствующего метода. Если язык не поддерживает свойства напрямую, то к ним всё равно можно обратиться посредством явного вызова метода, хоть такой код и выглядит менее элегантно.

### Автоматически реализуемые свойства

Если необходимо создать свойства для инкапсуляции резервных полей, то в C# есть упрощённый синтаксис, называемый автоматически реализуемыми свойствами (Automatically Implemented Properties, AIP).

Если объявить свойство без реализации методов доступа, то C# автоматически объявит поле закрытым, и компилятор автоматически реализует методы для правильного возвращения значения из поля и назначения значения полю. Преимущество автосвойства состоит в том, что если в последствии захочется изменить код методов доступа, то не придётся перекомпилировать исходный код.

Автор старается избегать автосвойств по нескольким причинам:
- Синтаксис объявления поля может включать инициализацию, таким образом, разработчик объявляет и инициализирует поле в одной строки. Автосвойства необходимо инициализировать во всех конструкторах. (прим. Возможность инициализации автосвойств появилась в C# 6)
- Механизм сериализации на этапе выполнения сохраняет имя поля в сериализованном потоке. Имя резервного поля для автосвойства определяется компилятором, и оно может меняться, сводя на нет возможности десериализации таких типов. Не стоит использовать автосвойства для типов, подлежащих сериализации и десериализации.
- Во время отладки нельзя установить точку останова в методах доступа. Точки можно устанавливать только в свойствах, которые разработчик описывает самостоятельно.

При использовании автосвойств свойства должны иметь уровень доступа для чтения и записи. Из-за того, что не известно имя автоматически генерируемого поля, программный код всегда должен обращаться к свойству по имени. А если разработчик решит явно реализовать один из методов доступа, то придётся явно реализовать оба метода, при этом отказавшись от автосвойств. Механизм автосвойств работает слишком бескомпромиссно.

### Осторожный подход к определению свойств

Автор был бы рад удалить поддержку свойств из .NET, потому что они порождают путаницу, по его мнению:
- Свойства могут быть доступны только для чтения или записи, в то время как поле всегда доступно для чтения и записи.
- Свойства, являясь методом, могут выдавать исключения, а при обращении к полям исключений не бывает.
- Свойства нельзя передавать в метод с ключевым словом `out`.
- Свойство-метод может выполняться довольно долго, в то время как обращение к полю происходит моментально. Часто свойства применяют для синхронизации потоков, но тогда поток может быть приостановлен на неопределённое время.
- При нескольких вызовах подряд свойство-метод может вернуть разные значения (например, `System.DateTime.Now`).
- Свойство-метод может порождать видимые побочные эффекты, невозможные при доступе к полю.
- Свойству-методу может требоваться дополнительная память или ссылка на объект, не являющийся частью состояния объекта, поэтому изменение возвращаемого объекта никак не сказывается на исходном объекте.

Автор считает, что разработчики используют свойства намного чаще, чем следовало бы. Да, свойства предоставляют удобный синтаксис, но при это теряются производительность и читаемость кода. (прим. _Я не согласен с автором. Может быть, действительно происходит потеря производительности, но синтаксис куда удобнее обычных полей._)

### Свойства и отладчик Visual Studio

...

### Инициализаторы объектов и коллекций 

Создание объекта с заданием некоторых открытых свойств (или полей) - чрезвычайно распространённая операция. Для её упрощения в C# предусмотрен специальный синтаксис:

```csharp
Employee e = new Employee() { Name = "Jeff", Age = 45 };
```

Компилируется это всё так, как если бы сначала был создан объект через вызов конструктора по умолчанию, потом были бы инициализированы поля, и в конце полученный объект присваивался бы переменной. 

Реальная выгода от синтаксиса инициализатора в том, что можно применять к полученному объекту цепочные функции:

```csharp
String s = new Employee() { Name = "Jeff", Age = 45 }.ToString().ToUpper();
```

C# также позволяет опускать круглые скобки перед открывающей фигурной, если разработчик хочет вызвать конструктор без параметров.

Если тип свойства реализует интерфейс IEnumerable или IEnumerable<T>, то свойство является коллекцией, а инициализация является дополняющей (а не заменяющей) операцией. Тогда код будет идентичен тому, как если бы сначала создалась коллекция, а потом элементы помещались бы туда по одному через метод `Add()`.

Если же тип реализует данные интерфейсы, но не имеет метода `Add()`, тогда коллекцию нельзя инициализировать.

### Анонимные типы

Механизм анонимных типов в C# позволяет объявить кортежный тип при помощи простого синтаксиса. _Кортежный тип_ (tuple type) - тип, который содержит коллекцию свойств, каким-то образом связанных друг с другом.

```csharp
var o1 = new { Name = "Jeff", Year = 1964 };
```

Здесь создаётся анонимный тип, потому что не был определён тип имени после `new`. Таким образом компилятор автоматически создаёт имя типа, но не сообщает его (поэтому тип и называется анонимным). В таком случае всегда используется неявная типизация с применением ключевого слова `var`.

При использовании анонимного типа, компилятор определяет тип каждого выражения, создаёт закрытые поля этих типов, для каждого поля созда1т открытые свойства только для чтения и для всех этих выражений создаёт конструктор.  Код конструктора инициализирует закрытые поля только для чтения путём вычисления результирующих значений. В дополнение к этому, компилятор переопределяет методы `Equals()`, `GetHashCode()` и `ToString()`.

Компилятор генерирует первые два метода, чтобы экземпляр анонимного типа могли размещаться в хеш-таблица. Неизменяемые свойства помогают защитить хеш-код объекта от изменений, так как это может помешать нахождению объекта в таблице. Последний же метод компилятор генерирует для упрощения отладки. 

Также свойства анонимного типа можно инициализировать переменными или их свойствами, без явного указания имени. Тогда имя и тип свойства анонимного типа будут совпадать с именем и типом выражения.

Компилятор очень разумно выявляет анонимный тип. Если он видит, что определено множество анонимных типов с идентичными структурами, то он создаёт одно определение этого типа и множество его экземпляров. Под одинаковой структурой подразумевается одинаковые типы, имена и порядок следования свойств.

Раз две переменные относятся к одинаковому типу, то их можно сравнивать, а также присваивать ссылку на один объект переменной другого объекта.

Раз эти типы идентичны, то можно создать массив из анонимных типов.

Анонимные типы обычно используются с технологией языка интегрированных запросов (Language INtegrated Query, LINQ), когда в результате выполнения запроса создаётся коллекция объектов, относящихся к одному анонимному типу.

Экземпляры анонимного типа не должны выходить за пределы метода. В прототипе метода не может содержаться параметр анонимного типа, так как задать его невозможно. По тому же принципу метод не может возвращать анонимный тип. Хотя экземпляры анонимного типа можно преобразовать к `object`, выполнить обратное преобразование нельзя, потому что имя анонимного типа на этапе компиляции неизвестно. Для передачи кортежного типа следует использовать `System.Tuple` (прим. _Или `dynamic`, хотя лучше этого не делать_).

### Тип System.Tuple

В пространстве имён `System` определено несколько обобщённых кортежных типов, которые отличаются количеством обобщённых параметров.

Как и объекты анонимного типа, объект `Tuple` создаётся один раз и остаётся неизменным. Кортеж позволяет использовать все базовые методы, а также методы сравнения (через реализацию в типе кортежа соответствующих интерфейсов).

Важно, чтобы производитель и потребитель кортежа имели чёткое представление о том, что возвращается в элементах кортежа. С анонимными типами свойства получают действительные имена на основании программного кода, инициализирующего их. Для кортежа имена назначаются автоматически и не имеют настоящего смысла, что ухудшает читабельность и сопровождение, так что появляется необходимость добавлять комментарии.

Чтобы создать кортеж с более чем восьмью элементами, стоит использовать вложенный кортеж.

Кроме анонимных и кортежных типов, стоит присмотреться к классу `System.Dynamic.ExpandoObject`. Он не обладает безопасностью типов, зато предоставляет удобный синтаксис. 

## Свойства с параметрами

Методы `get` свойств, описанные ранее, не принимали параметров. Поэтому такие свойства называются _свойствами без параметров_ (parameterless properties). Они проще, так как их использование напоминает обращение к полю. Помимо таких свойств, языки программирования поддерживают также _свойства с параметрами_ (parameterful properties). У таких свойств методы `get` принимают один или несколько параметров. В C# такие свойства называют _индексаторами_.

В C# синтаксис свойств с параметрами напоминает синтаксис массивов. Иначе говоря, свойства с параметрами представляют из себя перегрузку оператора `[]`

У каждого индексатора должен быть хотя бы один параметр, но может быть и несколько. Типы параметра и возвращаемого значения могут быть любыми.

Индексаторы довольно часто создаются для поиска значений в ассоциативном массиве (словаре). В отличие от свойств без параметров, индексаторы можно перегружать при условии, что их сигнатуры отличны.

Метод `set` индексатора содержит скрытый параметр, который указывает новое значение индексируемого объекта.

CLR не различает свойства с параметрами и без. Для среды любое свойство - это всего лишь пара методов в типе. Использование для индексатора в C# конструкции `this[...]` - всего лишь решение, означающее, что в C# индексаторы могут определяться только для экземпляров объектов. В C# нет синтаксиса, позволяющего разработчику определять статический индексатор, хотя сам CLR поддерживает такое.

Поскольку свойства без параметров и с ними обрабатываются CLR одинаково, компилятор генерирует в итоговой управляемой сборке два или три элемента из следующего списка:
- Метод `get` (только если определён соответствующий метод)
- Метод `set` (только если определён соответствующий метод)
- Определение свойства генерируется всегда

Компилятор автоматически генерирует имена методов индексатора, добавляя к имени индексатора префиксы `get_` и `set_`. Поскольку разработчик не может задать имя индексатора, компилятор сам проставляет имя `Item`. Если в документации сказано, что тип поддерживает свойство `Item`, значит, тип поддерживает индексатор.

Программируя на C#, разработчик не встретит имя `Item`. Однако при разработке типа с индексатором, который будет использоваться в программах на другой языке, стоит подумать об удобочитаемом имени, которое можно задать через специальный атрибут.

В C# можно перегружать индексаторы только по сигнатуре. В других языках можно создать индексаторы с одинаковой сигнатурой, так как имена могут отличаться. Однако C# не допускает такого, потому что не сможет найти, к какому индексатору обратиться.

В качестве примера типа с изменённым именем индексатора в C# выступает строка, так как имя Chars более информативно.

Обнаружив попытке чтения или записи индексатора, C# генерирует вызов соответствующего метода. Если язык не поддерживает индексаторы, то можно вызывать методы явно.

### Выбор главного свойства с параметрами

При анализе ограничений, которые C# налагает на индексаторы, возникает два вопроса:
- Что если язык, на котором написан тип, позволят определить несколько индексаторов?
- Как использовать этот тип в программе на C#?

Для этого надо применить специальный атрибут, который выбирал бы один из индексаторов как индексатор по умолчанию.

## Производительность при вызове методов доступа 

В случае простых методов доступа `get` и `set` JIT-компилятор _подставляет_ (inlines) код метода доступа внутрь кода вызываемого метода, поэтому характерного снижения производительности работы программы, проявляющегося при использовании свойств вместо полей, не наблюдается. Подстановка подразумевает компиляцию кода метода доступа непосредственно вместе с кодом вызывающего доступа. Это избавляет от дополнительной нагрузки, связанной с вызовом при выполнении, за счёт увеличения объёма кода. Это реализовано так потому, что код методов доступа обычно очень мал.

Однако при отладке JIT-компилятор не подставляет методы свойств, потому что такой код было бы сложнее отлаживать. Это значит, что в релизной версии скорость доступа к свойствам выше, чем в отладочной. Эффективность доступа к полям одинакова.

## Доступность метода доступа свойств

Иногда требуется применить различные модификаторы доступа к методам доступа. В таком случае компилятор C# требует, чтобы само свойство имело наименее жёсткое ограничение видимости, а методы доступа - более жёсткое.

## Обобщённые методы доступа свойств

Свойства фактически представляют собой методы, а C# и CLR поддерживает параметризацию методов, поэтому некоторые разработчики пытаются определить свойства со своими собственными параметрами-типами (вместо использования таких параметров из внешнего типа). Однако C# не позволяет это сделать. Главная причина в том, что обобщения лишены смысла с концептуальной точки зрения. Предполагается, что свойство представляет характеристику объекта, которую можно прочитать или задать. Введение обобщённого параметра типа означало бы, что поведение операции чтения/записи может меняться, но на концептуальном уровне от свойства не ожидается никакого поведения. Для задания поведения объекта стоит создать метод, а не свойство.
