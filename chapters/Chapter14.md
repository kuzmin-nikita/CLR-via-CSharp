## Символы

Символы в .NET представлены 16-разрядными кодами стандарта Юникод, что облегчает разработку многоязыковых приложений. Символ представляется экземпляром структуры `System.Char`. У него есть два открытых неизменяемых поля: константа `MinValue` равная `'\0'` и константа `MaxValue` равная `'\uffff'`. Для символа моно вызвать статический метод `char.GetUnicodeCategory()`, который возвращает категорию символа. Помимо этого, есть несколько статических методов, которые проверяют символ на принадлежность к какой-либо категории. Кроме того, есть методы, которые преобразовывают символ в его эквивалент в верхнем или нижнем регистре (с учётом или без региональных стандартов). Наконец, есть ещё несколько методов для сравнения символов, конвертации символов между кодировками или получении числового элемента символа. Подробнее о методах `char` в [документации](https://learn.microsoft.com/en-us/dotnet/api/system.char?view=net-8.0).

Существует три способа преобразования различных числовых типов в символ и наоборот:
- **Приведение типа.** Самый эффективный способ, так как компилятор генерирует IL-команды без вызовов методов. Для преобразования символа в число приведение подходит лучше всего. Кроме того, допускается указание необходимости использования проверяемого или непроверяемого кода.
- **Использование типа `System.Convert`.** У данного типа есть несколько статических методов, которые преобразуют число к символу и обратно. Все операции являются проверяемыми.
- **Использование интерфейса IConvertible.** Наименее эффективный метод, так как интерфейс необобщённый, что приводит к упаковке. Кроме того, методы интерфейса реализованы явно, из-за чего необходимо приводит символ к типу интерфейса. Помимо этого, все методы данного интерфейса за исключением `GetTypeCode()` принимают ссылку на объект, реализующий `IFormatProvider`. Он полезен, если преобразование требует учитывать региональные стандарты, но зачастую аргументом передаётся `null`. 

## Тип System.String

Строка представляет собой неизменяемый упорядоченный набор символов. Будучи прямым потомком `System.Object`, строка является ссылочным типом, поэтому всегда размещается в куче. 

### Создание строк

Строка относится к примитивным типам, то есть компилятор разрешает вставлять литеральные строки непосредственно в исходный код. компилятор помещает эти литеральные строки в метаданные модуля, откуда они загружаются и используются во время выполнения. В C# нельзя создать строку через конструктор с использованием строкового литерала `String s = new String("Hi there.");`, но можно с использованием более простого синтаксиса `String s = "Hi there.";`.

Если заглянуть в IL-код примера создания строки, то можно заметить, что новый объект не создаётся. Вместо этого происходит загрузка строки, которая создаёт новый объект на основе литеральной строки, полученной из метаданных. Всё потому, что объекты String в CLR создаются по специальной схеме.

Используя небезопасный код можно создать строку с использованием указателя на символ или знаковый байт. Для этого следует применить конструктор, принимающий соответствующие параметры. Эти конструкторы создают объект и заполняют его строкой, состоящей из указанного массива символов или байтов со знаком. У других конструкторов не параметров-указателей, их можно вызвать из любого языка, создающего управляемый код.

В C# имеется специальный синтаксис для включения литеральный строк в исходный код. Для вставки специальных символов используются управляющие последовательности. Задавать в коде последовательность символов конца строки и перевода каретки напрямую не стоит, так как последовательность может отличаться для различных платформ. Для этих целей необходимо использовать неизменяемое свойство `System.Environment.NewLine`.

Для объединения нескольких строк в одну можно использовать оператор `+`. Если все операнды являются литералами, то конкатенация произойдёт на этапе компиляции. Конкатенация нелитеральных строк с помощью данного оператора происходит на этапе выполнения, но использовать оператор в этом случае нежелательно, так как это создаёт в куче несколько новых строковых объектов. Для этих целей стоит использовать `StringBuilder`.

Наконец, в C# есть особый вариант объявления строки, в которой все символы трактуются как часть строки. Это специальные объявления - _буквальные строки_ (verbatim strings) - обычно используют при задании пути к файлу или каталоге. Для объявления этих строк используется символ `@` переда кавычками.

### Неизменяемые строки

Самое важное, что нужно помнить о строковом объект - он неизменяем. То есть однажды созданную строку нельзя сделать длиннее или короче и в ней нельзя изменить ни одного символа. Неизменность строк даёт определённые преимущества. Для начала можно выполнять операции над строками, не изменяя их. Любые методы, применяемые к строке, возвращают новую строку. Если результат применения метода к строке не присваивать переменной, то на данный объект в куче не останется ссылок, и он будет удалён при очередной сборке мусора. Если со строками выполняется много операций, то это заставляет чаще прибегать к сборке мусора, из-за чего страдает производительность.

Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками. Кроме того, в CLR несколько ссылок `string` могут указывать на один, а не на несколько разных строковых объектов, если строки идентичны. Значит, можно сократить количество различных строковых объектов и уменьшить расход памяти - этот механизм называется `интернированием строк` (string interning).

По соображениям производительности тип `String` тесно интегрирован с CLR: среда знает точное расположение полей в этом типе и обращается к ним напрямую. За повышение производительности и прямой доступ приходится платить некоторую цену: класс `string` является запечатанным. Потому что в противном случае код разработчика могу бы нарушить внутреннюю структуру строки и предположения CLR о ней.

### Сравнение строк

Сравнение - наиболее часто выполняемая операция со строками. Сравнение необходимо для выяснения равенства (например, равенство при фильтрации) и для сортировки. Для сравнения строк лучше всего использовать один из методов, реализованных в классе `String`. Методы сравнения более гибкие и позволяют указывать такие параметры как региональные стандарты и опции сравнения.

Для решения внутренних задач и сравнения, например, XML-тегов следует использовать флаги `StringComparision.OrdinalIgnoreCase` или `StringComparision.Ordinal`, так как это самый быстрый способ сравнения из-за игнорирования лингвистически особенностей и региональных стандартов. Если же требуется сравнить строки с точки зрения лингвистических особенностей (например, перед выводом на экран пользователя), то стоит использовать флаги `StringComparision.CurrentCultureIgnoreCase` или `StringComparision.CurrentCulture`. И хотя данные флаги помогают корректно сравнить строки с лингвистической точки зрения, они замедляют работу программы. Кроме того, игнорирование региональных стандартов - не очень удачный выбор для сортировки строк. Если же перед сравнением разработчик хочет изменить регистр, то лучше использовать `ToUpperInvariant()`, так как сравнение строк в верхнем регистре более оптимизировано. На самом деле при независящем от регистра сравнении строки приводятся именно к верхнему регистру.

Иногда для лингвистически корректного сравнения необходимо использовать региональные стандарты отличные от региональных стандартов вызывающего потока. В этом случае стоит использовать один из методов, принимающий в качестве параметра `CultureInfo`.

Для предоставления пары "язык-страна" в .NET используется тип `System.Globalization.CultureInfo`. В CLR у каждого потока есть два свойства, относящиеся к этой паре и ссылающиеся на объект `CultureInfo`:
- `CurrentUICulture` служит для получения ресурсов, видимых конечному пользователю (наиболее частый случай применения - WinForms или WebForms, где язык определяется текущей версией Windows).
- `CurrentCulture` используется во всех остальных случаях.

Автор советует применять следующие методы равнения:

```csharp 
Boolean Equals(String value, StringComparison comparisonType)

static Boolean Equals(String a, String b, StringComparison comparisonType)

static Int32 Compare(String strA, String strB, StringComparison comparisonType)

static Int32 Compare(string strA, string strB, Boolean ignoreCase, CultureInfo culture)

static Int32 Compare(String strA, String strB, CultureInfo culture, CompareOptions options)

static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length, StringComparison comparisonType)

static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length, CultureInfo culture, CompareOptions options)

static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length, Boolean ignoreCase, CultureInfo culture)

Boolean StartsWith(String value, StringComparison comparisonType)

Boolean StartsWith(String value, Boolean ignoreCase, CultureInfo culture)

Boolean EndsWith(String value, StringComparison comparisonType)

Boolean EndsWith(String value, Boolean ignoreCase, CultureInfo culture)
```

Автор советует избегать остальных методов сравнения, в том числе и операторов `==` и `!=`, так как этот код не определяет явно КАК должно выполняться сравнение строк, что ухудшает читаемость.

Кроме того, в FCL есть класс `System.StringComparer`, который можно применять в ситуациях, когда необходимо многократно выполнять однотипные операции сравнения. 

### Интернирование строк

Сравнение строк используется во многих приложениях, но эта операция может существенно сказаться на производительности. При _порядковом сравнении_ (ordinal comparision) CLR быстро проверяет, равно ли количество символов в строках и, если длина одинакова, сравнивает строки посимвольно. При сравнении с учётом региональных стандартов строки также приходится сравнивать посимвольно, потому что они могут быть разной длины.

К тому же хранение в памяти нескольких экземпляров одной строки приводит к непроизводительным затратам памяти - ведь строки неизменяемы. Эффективного использования памяти можно добиться, если хранить одну строку, на которую буду указывать соответствующие ссылки.

Если в приложении строки сравниваются методом порядкового сравнения или если в приложении ожидается множество одинаковых строк, то для повышения производительности надо применить поддерживаемый CLR механизм _интернирования строк_ (string interning). При инициализации CLR создаёт внутреннюю хеш-таблицу, в которой ключами являются троки, а значениями - ссылки на строковые объекты в управляемой куче. В классе `String` есть два публичных метода, предоставляющих доступ к внутренней хеш-таблице. Метод `Intern()` ищет строку во внутренней хеш-таблице и, если строка найдена, возвращает ссылку на соответствующий объект, иначе создаётся новая запись в хеш-таблице и возвращается ссылка. Если приложение больше не удерживает ссылку на исходную строку, то сборщик мусора может освободить память. Второй метод `IsInterned()` проверяет, находится ли строка в хеш-таблице и возвращает ссылку на строку, если строка найдена, иначе возвращает `null` и не вставляет строку в таблицу.

По умолчанию при загрузке сборки CLR интернирует все литеральные строки, описанные в метаданных сборки. Выяснилось, что это отрицательно сказывалось на производительности из-за необходимости дополнительного поиска в хеш-таблице, поэтому теперь Microsoft позволяет отключить этот функционал. Даже если в сборке отключён этот функционал, CLR может предпочесть интернировать строки. Однако не стоит писать код, рассчитанный на интернирование, если явно не вызывается метод `Intern()`.

Интернирование строк ускоряет работу только в тех случаях, когда к интернированным строкам обращается чаще, чем записывают новые. Именно по этой причине компилятор указывает, что не следует разрешать интернирование строк.

### Создание пулов строк

_Создание пулов строк_ (string pooling) - ещё один способ ускорения обработки строк. Если в исходном коде несколько раз встречается одна и та же литеральная строка, то чтобы не раздувать метаданные модуля, компилятор хранит строку в единственном экземпляре, а все упоминания строки в исходном коде заменяются на ссылку.

### Работа с символами и текстовыми элементами в строке

Сравнение строк полезно при сортировке и поиске одинаковых строк, однако иногда требуется проверять отдельные символы в пределах строки. У `String` есть несколько методов и свойств под это дело. 

На самом деле `System.Char` представляет одно 16-разрядное кодовое значение в кодировке Юникод, которое необязательно соответствует абстрактному Юникод-символу. Некоторые абстрактные Юникод-символы являются комбинацией двух кодовых значений, которые образуют текстовый элемент.

Кроме того, представление некоторых текстовых элементов требует не одного, а двух 16-разрядных кодовых значений. Первое называют _старшим_ (high surrogate), а второе - _младшим заменителем_ (low surrogate). Такой способ кодировки позволяет представить в Юникод более миллиона различных символов.

Для корректной работы с текстовыми элементами предназначен тип `System.Globalization.StringInfo` Самый простой способ воспользоваться им - создать экземпляр через конструктор, которому надо передать строку.

### Прочие операции со строками

Методы типа `String` предназначенные для полного или частичного копирования:

| Член      | Тип метода   | Описание                                                                                                                                    |
|-----------|--------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| Clone     | Экземплярный | Возвращает ссылку на тот же объект                                                                                                          |
| Copy      | Статический  | Возвращает новую строку - дубликат. Обратная операция интернированию - создаёт новый объект с тем же содержимым и возвращает иной указатель |
| CopyTo    | Экземплярный | Копирует группу символов строки в массив                                                                                                    |
| Substring | Экземплярный | Возвращает новую строку, представляющую часть исходной строки                                                                               |
| ToString  | Экземплярный | Возвращает ссылку на тот же объект                                                                                                          |

Кроме этих методов есть ещё много статических и экземплярных методов для различных операций со строками.

## Эффективное создание строк

Тип `String` представляет собой неизменяемую строку, а для динамических операций со строками и символами в FCL используется `System.Text.StringBuilder`. Его можно рассматривать как некий общедоступный конструктор. 

У объекта `StringBuilder` предусмотрено поле со ссылкой на массив структур `Char`. Используя члены `StringBuilder`, можно эффективно манипулировать этим массивом, сокращая строку и изменяя символы строки. При увеличении строки, билдер автоматически выделит память для нового, больше по размеру массива, скопирует символы и приступит к работе с новым массивом. А прежний массив попадёт в область сборщика мусора. После всех манипуляций из билдера можно вернуть ссылку на результирующее поле-строку.

## Создание объекта StringBuilder

Объект `StringBuilder` создаётся так же, как и любой объект непримитивного типа - через конструктор. Конструкторов существует несколько. Задача каждого из них - выделить память и инициализировать три внутренних поля:
- **Максимальная ёмкость** (maximum capacity) - задаёт максимальное число символов в строке.
- **Ёмкость** (capacity) - размер массива символов; лучше задать явно, если известен конечный размер строки, так как при добавлении символов, которые не помещаются в текущий массив, ёмкость удваивается, что негативно сказывается на производительности.
- **Массив символов** (character array) - число символов в массиве; при создании билдера стоит инициализировать строкой.

## Члены типа StringBuilder

Тип `StringBuilder` представляет изменяемую строку - многие члены типа изменяют содержимое в массиве символов, не создавая новых объектов в куче за исключением двух случаев:
- При динамическом построении строки, размер которой превышает установленную ёмкость.
- При вызове метода `ToString()`.

Методы класса `StringBuilder` можно найти в [документации](https://learn.microsoft.com/ru-ru/dotnet/api/system.text.stringbuilder?view=net-8.0).

Большинство методов билдера возвращают ссылку на тот же билдер, так что можно выстраивать методы в цепочку. Однако билдер поддерживает не все методы типа `String`, из-за чего может появиться необходимость гонять данные между билдером и строкой. Такой код неудобен и стоит только надеяться, что в будущем Microsoft улучшат `StringBuilder`.

## Получение строкового представления объекта

Для получения строковому представления любому типу необходимо переопределить метод `ToString()` типа `Object`, так как по умолчанию он выводит только полное название типа. Плюс к этому надо учитывать региональные ограничения, чтобы строковое представление было корректно.

### Форматы и региональные стандарты

У метода `ToString()` без параметров есть два недостатка:
- Вызывающая программа не управляет форматированием строки (например, когда программе нужно представить число в денежном или десятичном формате).
- Вызывающая программа не может выбрать формат, учитывающий конкретные региональные стандарты (наиболее актуально для серверных приложений).

Тип может предложить вызывающей программе выбор форматирования и региональных стандартов. если он реализует интерфейс `System.IFormattable`. Реализация этого интерфейса есть у всех базовых типов в FCL, кроме того, реализация этого интерфейса есть у `GUID` и перечислимых типов. Метод `ToString()` данного интерфейса принимает два параметра: строка, сообщающая методу способ форматирования объекта, и экземпляр типа, который реализует интерфейс `System.IFormatProvider`, который предоставляет информацию о региональных стандартах.   

Тип, реализующий интерфейс `System.IFormattable`, определяет допустимые варианты форматирования. Если переданная строка форматирования неприемлема, тип должен генерировать исключение. Подробнее про форматы можно прочитать в документации форматов [дат](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings) и [чисел](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings). При передаче в качестве формата `null` или вызове метода без параметров будет применено форматирование по умолчанию, которое, подразумевается, используется чаще остальных.

По умолчанию региональные стандарты применяются из вызывающего потока. Основная идея применения IFormatProvider состоит в том, чтобы экземпляр знал, как обеспечить учёт региональных стандартов при форматировании и проигнорировать региональные стандарты по умолчанию. В FCL данный интерфейс реализуется только тремя типами: `CultureInfo`, `NumberFormatInfo` и `DateTimeFormatInfo`.

### Форматирование нескольких объектов в одну строку

До сих пор речь шла о форматировании конкретных объектов типа. Но иногда требуется сформировать строку из множества отформатированных объектов. Для этого существует статический метод `String.Format()`. Он получает строку форматирования, в которой подставляемые параметры обозначены своими номерами в фигурных скобках. Внутри метода для каждого объекта вызывается `ToString()`. Все возвращённые строки затем объединяются, а полученный результат возвращается методом. Стоит заметить, что ко всем объектам применяется общий формат и региональные стандарты. Это можно изменить, если добавить внутрь фигурных скобок строку форматирования.

Если вместо `String` для формирования строки применяется `StringBuilder`, то для него существует отдельный метод `AppendFormat()`. Он работает так же, как и `Format()` для строки с тем отличием, что итог форматирования добавляется результирующему массиву символов. Для `System.Console` также есть методы, которые могут применять строку форматирования и замещаемые параметры, но в неё нельзя передать `IFormatProvider`, хотя это можно легко обойти вызовом `String.Format()`.

### Создание собственного средства форматирования

.NET обладает достаточно гибкими средствами форматирования. Однако помимо этого, можно написать свои методы, которые будут вызываться в `AppendFormat()`, которые будут вызываться для объектов любого типа вместо `ToString()`. 

## Получение объекта посредством разбора строки

Получать объект из строки требуется нечасто, однако это может быть крайне полезно.

Любой тип, способный разобрать строку, имеет открытый, статический метод `Parse()`. Он получает строку, а возвращает объект данного типа. Данный метод имеют все числовые типы, а также типы даты и времени (и некоторые другие).

Строка парсится в число или дату с применением соответствующих флагов подробнее в документации о [числах](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.numberstyles?view=net-8.0) и [датах](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.datetimestyles?view=net-8.0). 

Дата и время плохо поддаются синтаксическому разбору, поэтому в типе `DateTime` существует метод `ParseExact()`, который анализирует строку согласно некоторому шаблону.

Некоторые разработчики заметили, что если при многократных вызовах метода `Parse()` возникают исключения, то это негативно сказывается на производительности. Для таких случаев существует метод `TryParse()`, который сначала проверяет возможность парсинга, и только потом парсит строку в переменную. 

## Кодировки: преобразование между символами и байтами

Иногда требуется записать текст в файл или передать его по сети. Когда текст состоит преимущественно из символов английского языка его крайне неэффективно кодировать юникодов, потому что половина байтов просто пустые. Разумнее сначала _закодировать_ (encode) символы в более компактный массив байтов, чтобы потом _декодировать_ (decode)/ Кодирование также помогает приложениям работать со строками, созданных в системах, не поддерживающих Юникод.

Кодирование выполняется перед отправкой строки в файл или сетевой поток с помощью типов `System.IO.BinaryWriter` и `System.IO.StreamWriter`. Декодирование происходит при чтении из файла или сетевого потока с помощью типов `System.IO.BinaryReader` и `System.IO.StreamReader`.

В FCL имеются типы, упрощающие операции кодирования и декодирования. К наиболее часто используемым кодировкам относятся UTF-16 и UTF-8. Помимо них FCL поддерживает также UTF-32, UTF-7 и ASCII. Подробнее о кодировках можно почитать [тут](https://neerc.ifmo.ru/wiki/index.php?title=Представление_символов,_таблицы_кодировок).

Чтобы выполнить кодирование или декодирование набора символов, сначала необходимо получить экземпляр класса, производного от `System.Text.Encoding`. Подробнее о типах в [документации](https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding?view=net-8.0). 

### Кодирование и декодирование потоков символом и байтов

Для декодирования потока байтов, которые могут приходить частями стоит применять тип производный от класса `System.Text.Decoder`. Он умеет корректно принимать байты и, если байтов не хватало, оставляет их для сложения с будущей порцией входных байтов.

### Кодирование и декодирование строк в кодировке Base-64

Кроме UTF-16 и UTF-8 очень часто применяется кодирование последовательности байтов в строке в кодировке base-64. Для этого в .NET существуют отдельные статические методы, предоставляемые типов `System.Convert`. 

## Защищённые строки

Часто строки применяют для хранения конфиденциальных данных. К сожалению, строки хранятся в памяти массивом байтов, и, если разрешить выполнение небезопасного или неуправляемого кода, он сможет просмотреть адресное пространство, найти строку и использовать её в своих целях. Даже если строка живёт недолго и становится добычей сборщика мусора, CLR может не сразу задействовать ранее занятую память, оставляя символы объекта в памяти. Кроме того, поскольку строки являются неизменяемыми. предыдущие их версии также лежат в памяти.

Для реализации защищённых строк Microsoft добавила в FCL безопасный строковый класс System.Security.SecureString. При создании объекта этого типа его код выделяет блок в неуправляемой памяти, которая содержит массив символов. Сборщик мусора об этой памяти ничего не знает.

Символы строки шифруются для защиты конфиденциальной информации от любого потенциально опасного кода. Для изменения такой строки существуют соответствующие методы. При вызове любого из них символы расшифровываются, операция выполняется, после чего символы снов шифруются. Это значит, что символы хранятся в незашифрованном виде очень недолгое время. Такие строки, конечно, модифицируются там же, где хранятся, но скорость операций всё равно конечна, так что это может сказаться на быстродействии.

Данный класс реализует интерфейс `IDisposable`, что гарантирует надёжное уничтожение конфиденциальной информации. Вызов метода `Dispose()` сначала обнуляет содержимое буфера в памяти, и только после этого буфер освобождается. Символы такой строки не остаются в памяти. 

В .NET 4 передать `SecureString` в качестве пароля можно в следующих случаях:
- При работе с криптографическим провайдером.
- При создании, импорте или экспорте сертификата X.509.
- При запуске нового процесса под определённой учётной записью пользователя.
- При организации нового сеанса записи журнала событий.
- При использовании элемента управления окна ввода пароля.

Наконец, можно самостоятельно создавать методы, принимающие в качестве аргумента `SecureString`. В методе надо задействовать объект данного типа для создания буфера в неуправляемой памяти, хранящего расшифрованные символы, до использования этого буфера в методе. Чтобы сократить временное окно доступа к конфиденциальным данным, код должен обращаться к расшифрованное строке минимально возможное время. После использования строки следует как можно скорее обнулить буфер. Никогда нельзя размещать защищённую строку в обычной строке, иначе данные будут лежать там до тех пор, пока не произойдёт сборка мусора и память не перезапишется. Исходя из этих соображений данный класс не переопределяет метод `ToString()`. Подробнее о данном классе можно почитать в [документации](https://learn.microsoft.com/ru-ru/dotnet/api/system.security.securestring?view=net-8.0).
