## Символы

Символы в .NET представлены 16-разрядными кодами станларта Юникод, что облегчает разработку многоязыковых приложений. Символ представляется экземпляром структуры `System.Char`. У него есть два открытых неизменяемых поля: константа `MinValue` равная `'\0'` и константа `MaxValue` равная `'\uffff'`. Для символа моно вызвать статический метод `char.GetUnicodeCategory()`, который возвращает категорию символа. Помимо этого есть несколько статических методов, которые проверяют символ на принадлежность к какой-либо категории. Кроме того, есть методы, которые преобразовывают символ в его эквивалент в верхнем или нижнем регистре (с учётом или без региональных стандартов). Наконец, есть ещё несколько методов для сравнения символов, конвертации символов между кодировками или получении числововго элемента символа. Подрообнее о методах `char` в [документации](https://learn.microsoft.com/en-us/dotnet/api/system.char?view=net-8.0).

Существует три спосба преобразования различных числовых типов в символ и наоборот:
- **Приведение типа.** Самый эффективный способ, так как компилятор генерирует Il-команды без вызовов методов. Для преобразования чимвола в число приведение подходит лучше всего. Кроме того, допускается указание необходимости использования проверяемого или непроверяемого кода.
- **Использование типа `System.Convert`.** У данного типа есть несколько статических методов, которые преобразуют число к символу и обратно. Все операции являются проверяемыми.
- **Использование интерфейса IConvertible.** Наименее эффективный метод, так как интерфейс необобщённый, что приводит к упаковке. Кроме того, методы интерфейса реализованы явно, из-за чего необходимо приводит символ к типу интерфейса. Помимо этого все методы данного интерфейса за исключением `GetTypeCode()` принимат ссылку на объект, реализующий `IFormatProvider`. Он полезен, если преобразование требует учитывать региональные стандараты, но зачастую аргументом передаётся `null`. 

## Тип System.String

Строка представляет собой неизменяемый упорядоченный набор символов. Будучи прямым потомком `System.Object`, стркоа является ссылочным типом, поэтому всегда размещается в куче. 

### Создание строк

Строка относится к примитивным типам, то есть компилятор разрешает вставлять литеральные строки непосредственно в исходный код. компилятор помещает эти литеральные строки в метеданные модуля, откуда они загружаются и используются во время выполнения. В C# нельзя создать строку через конструктор с использованием строкового литерала `String s = new String("Hi there.");`, но можно с использованием более простого синтаксиса `String s = "Hi there.";`.

Если заглянуть в IL-код примера создания строки, то можно заметить, что новый объект не создаётся. Вместого этого происходит загрузка строки, которая создаёт новый объект на основе литеральной строки, полученной из метаданных. Всё потому, что объекты String в CLR создаются по специальной схеме.

Используя небезопасный код можно содать строку с использованием указателя на символ или знаковый байт. Для этого следует применить конструктор, принимающий соответствующие параметры. Эти конструкторы создают объект и заполняют его строкой, состоящей из указанного массимва символов или байтов со знаком. У других конструкторов не параметров-указателей, их можно вызвать из любого языка, создающего управляемый код.

В C# имеется специальный синтаксис для включения литеральный строк в исходный код. Для вставки специальных символов используются управляющие последовательности. Задавать в коде последовательность символов конца строки и переавода каретки напрямую не стоит, так как последовательность может отличаться для различных платформ. Для этих целей необходимо использовать неизменяемое свойство `System.Environment.NewLine`.

Для объединения нескольких строк в одну можно использовать оператор `+`. Если все операнды являются литералами, то конкатенация произойдёт на этапе компиляции. Конкатенация нелитеральных строк с помощью данного оператора происходит на этапе выполнения, но использовать оператор в этом случае нежелательно, так как это создаёт в куче несклько новых строковых объектов. Для этих целей стоит использовать `StringBuilder`.

Наконец, в C# есть особый вариант объявления строки, в которой все символы трактуются как часть строки. Это специальные объявления - _буквальные строки_ (verbatim strings) - обычно используют при задании пути к файлу или каталоге. Для объявления этих строк используется символ `@` переда кавычками.

### Неизменяемые строки

Самое важное, что нужно помнить о строковом объект - он неизменяем. То есть однажды созданную строку нельзя сделать длиннее или короче и в ней нельзя изменить ни одного символа. Неизменность строк даёт определённые преимущества. Для начала можно выполнять операции над строками, не изменяя их. Любые методы, применяемые к строке, возвращают новую строку. Если результат применения метода к строке не присваивать переменной. то на данный объект в куче не останется ссылок и он будет удалён при олчередной сборке меусора. Если со строками выполняется много операций, то это заставляет чаще прибегать к сборке мусора, из-за чего страдает производительность.

Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками. Кроме того, в CLR несссколько ссылок `string` могут указывать на один, а не на несколько разных строковых объектов, если строки идентичны. Значит, можно сократить количество различных строковых объектов и уменьшить расход памяти - этот механизм называется `интернированием строк` (string interning).

По соображениям производительности тип `String` тесно интегрирован с CLR: среда знает точное расположение полей в этом типе и обращается к ним напрямую. За повышение производительности и прямой доступ приходится платить некоторую цену: класс `string` является запечатанным. Потому что в противном случае код разработчика могу бы нарушить внутреннюю структуру строки и предположения CLR о ней.

### Сравнение строк

Сравнение - наиболее часто выполняемая операция со строками. Сравнение необходимо для выяснения равенства (например, равенство при фильтрации) и для сортировки. Для сравнения строк лучше всего использовать один из методов, реализованны в классе `String`. Методы сравнения более гибкие и позволяют указывать такие параметры как региональные стандарты и опции сравнения.

Для решения внутренних задач и сравнения, например, XML-тегов следует использовать флаги `StringComparision.OrdinalIgnoreCase` или `StringComparision.Ordinal`, так как это самый быстрый способ сравнения из-за игнорирования лингвистически особенностей и региональных стандартов. Если же требуется сравнить строки с точки зрения лингвистических особенностей (например, перед выводом на экран пользователя), то стоит использовать флаги `StringComparision.CurrentCultureIgnoreCase` или `StringComparision.CurrentCulture`. И хотя данные флаги помогают корректно сравнить строки с лингвистической точки зрения, они замедляют работу программы. Кроме того, игнорирование региональных стандартов - не очень удачный выбор для сортировки строк. Если же перед сравнением разработчик хочет изменить регистр, то лучше использовать `ToUpperInvariant()`, так как сравнение строк в верхнем регистре более оптимизировано. На самом деле при независящем от регистра сравнии строки приводятся именно к верхнему регистру.

Иногда для лингвистически корректного сравнения необходимо использовать региональные стандарты отличные от региональных стандартов вызывающего потока. В этом случае стоит использовать один из методов, принимающий в качестве параметра `CultureInfo`.

Для предоставления пары "язык-страна" в .NET используется тип `System.Globalization.CultureInfo`. В CLR у каждого потока есть два свойства, относящиеся к этой паре и ссыающиеся на объект `CultureInfo`:
- `CurrentUICulture` служит для получение ресурсов, видимых конечному пользователю (наиболее частый случай применения - WinForms или WebForms, где язык определяется текущей версией Windows).
- `CurrentCulture` используется во всех остальых случаях.

Автор советует применять следующие методы равнения:

```csharp 
Boolean Equals(String value, StringComparison comparisonType)

static Boolean Equals(String a, String b, StringComparison comparisonType)

static Int32 Compare(String strA, String strB, StringComparison comparisonType)

static Int32 Compare(string strA, string strB, Boolean ignoreCase, CultureInfo culture)

static Int32 Compare(String strA, String strB, CultureInfo culture, CompareOptions options)

static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length, StringComparison comparisonType)

static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length, CultureInfo culture, CompareOptions options)

static Int32 Compare(String strA, Int32 indexA, String strB, Int32 indexB, Int32 length, Boolean ignoreCase, CultureInfo culture)

Boolean StartsWith(String value, StringComparison comparisonType)

Boolean StartsWith(String value, Boolean ignoreCase, CultureInfo culture)

Boolean EndsWith(String value, StringComparison comparisonType)

Boolean EndsWith(String value, Boolean ignoreCase, CultureInfo culture)
```

Автор советует избегать остальных методов сравнения, в том чиле и операторов `==` и `!=`, так как этот код не определяет явно КАК должно выполняться сравнение строк, что ухудшает читаемость.

Кроме того, в FCL есть класс `System.StringComparer`, который можно применять в ситуациях, когда необходимо мнолгократно выполнять однотипные операции сравнения. 

### Интернирование строк

Сравнение строк используется во многих приложениях, но эта операция может существенно сказаться на производительности. При _порядковом сравнении_ (ordinal comparision) CLR быстро проверяет, равно ли количество символов в строках и, если длина одинакова, сравнивает строки посимвольно. При сравнении с учётом региональных стандартов строки также приходится сравнивать посимвольно, потому что они могут быть разной длины.

К тому же хранение в памяти нескольких экземпляров одной строки приводит к непроизводительным затратам памяти - ведь строки неизменяемы. Эффективного использования памяти можно добиться, если хранить одну строку, на которую буду указывать соответствующие ссылки.

Если в приложении строки сравниваются методом порядкового сравнения или если в приложении ожидается множество одинаковых строк, то для повышени производительности надо применить поддерживаемый CLR механизм _интернирования строк_ (string interning). При инициализации CLR создаёт внутреннюю хеш-таблицу, в которой ключами являются троки, а значениями - ссылки на строковые объекты в ууправляемой куче. В классе `String` есть два публичных метода, предоставляющих доступ к внутренней хеш-таблице. Метод `Intern()` ищет строку во внутренней хеш-таблице и, если строка найдена, возвращает ссылку на соответстввующий объект, иначе создаётся новая запись в хеш-таблице и возвращается ссылка. Если приложение больше не удерживает ссылку на исходную строку, то сборщик мусора может освободить память. Второй метод `IsInterned()` проверяет, находится ли строка в хеш-таблиуце и возвращает ссылку на строку, если строка найдена, иначе возвращает `null` и не вставляет строку в таблицу.

По умолчанию при загрузке сборки CLR интернирует все литеральные строки, описанные в метаданныхх сборки. Выяснилось, что это отрицательно сказывалось на производительности из-за необходимости дополнительного поиска в хеш-таблице, поэтому терперь Microsoft позволяет отключить этот функционал. Даже если в сборке отключён этот функционал, CLR может предпочесть интернировать строки. Однако не стоит писать код, рассчитанный на интернирование, если явно не вызывается метод `Intern()`.

Интернирование строк ускоряет работу только в тех случаях, когда к интернированным строкам обращатся чаще, чем записывают новые. Именно по этой причине компилятор уазывает, что не следует разрешать интернирование строк.

### Создание пулов строк

_Создание пулов строк_ (string pooling) - ещё один способ ускорения обработки строк. Если в исходном коде несколько раз встречается одна и та же литеральная строка, то чтобы не раздувать метаданныые модуля, компилятор хранит строку в единственном экземпляре, а все упоминания строки в исходном коде заменяются на ссылку.

### Работа с символами и текстовыми элементами в строке

Сравнение строк полезно при сортировке и поиске одинаковых строк, однако иногда требуется проверять отдельные символы в пределах строки. У `String` есть несколько методов и свойств под это дело. 

На самом деле `System.Char` представляет одно 16-разрядное кодовое значение в кодировке Юникод, которое необязательнос соответствует абстрактному Юникод-символу. Некоторые абстрактные Юникод-символы являются комбинацией двух кодовых значений, которые образуют текстовый элемент.

Кроме того,предлставление некоторых текстовых элементов требует не одного, а двух 16-разрядных кодовых значений. Первое называют _старшим_ (high surrogate), а второе - _младшим заменителем_ (low surrogate). Такой способ кодировки позволяет представить в Юникод более миллиона различных символов.

Для корректной работы с текстовыми элементами предназначен тип `System.Globalization.StringInfo` Самый ппростой способ воспользоваться им - создать экземпляр через конструктор, которому надо передать строку.

### Прочие операции со строками

Методы типа `String` предназначенные для полного или частичного копирования:

| Член      | Тип метода   | Описание                                                                                                                                    |
|-----------|--------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| Clone     | Экземплярный | Возвращает ссылку на тот же объект                                                                                                          |
| Copy      | Статический  | Возвращает новую строку - дубликат. Обратная операция интернированию - создаёт новый объект с тем же содержимым и возвращает иной указатель |
| CopyTo    | Экземплярный | Копирует группу символов строки в массив                                                                                                    |
| Substring | Экземплярный | Возвращает новую строку, представляющую часть исходной строки                                                                               |
| ToString  | Экземплярный | Возвращает ссылку на тот же объект                                                                                                          |

Кроме этих методов есть ещё много статических и экземплярных методов для различных операций со строками.

## Эффективное создание строк



## Создание объекта StringBuilder



## Члены типа StringBuilder



## Получение строкового представления объекта



### Форматы и региональные стандарты



### Форматирование нескольких объектов в одну строку



### Создание собственного средства форматирования



## Получение объекта посредством разбора строки



## Кодировки: преобразование между символами и байтами



### Кодирование и декодирование потоков символом и байтов



### Кодирование и декодирование строк в кодировке Base-64



## Защищённые строки

