##  Для чего Windows поддерживает потоки?

На заре компьютерной эры не существовало концепции _потоков исполнения_; точнее, существовал только один поток. При этом выполнение приложения могло ставить на паузу работу операционной системы.

Для решения этой проблемы было решено запускать каждый экземпляр приложения в отдельном _процессе_. Процессом называется набор ресурсов, используемый отдельным экземпляром приложения. Каждому процессу выделяется виртуальное адресное пространство, которое гарантирует изолированность приложений друг от друга.

Однако, если процессор один, а приложение войдёт в бесконечный цикл, то это всё так же ставит систему в тупик. Для решения этой проблемы были придуманы _потоки_ (threads). Потоки предназначены для виртуализации процессора. Если код войдёт в бесконечный уикл, то блокируется только связанный с этим кодом процесс.

## Ресурсоёмкость потоков

Как и любые мнеханизмы виртуализации, потоки потребляют дополнительные ресурсы, требуя памяти и времени (снижая производительность среды выполнения). Каждый поток состоит из нескольких частей:
- **Объект ядра потока** (thread kernel object). Операционная система выделяет и инициализирует для каждого созданного к ней потока одну из структур данных, которая опиывает поток.
- **Блок окружения поток** (Thread Environment Block, TEB). Место в памяти, выделенное и инициализированне в пользовательском режиме (адресное пространство, к которому приложение имеет быстрый доступ). Блок содержит заголовок цепочки обработки исключений, а также локальное хранилище данных для потока.
- **Стек пользовательского режима** (user-mode stack). Хранит передаваемые в методы локальные переменные и аргументы. Также содержит адрес, показывающий, откуда начнёт исполнение поток после того, как текущий метод возвратит управление.
- **Стек режима ядра** (kernel-mode stack). Используется, когда код приложения передаёт аргументы в функцию операционной системы, находящейся в режиме ядра.
- **Уведомления о создании и завершении потоков.** Передаются в каждую загруженную в процесс DLL, чтобы выполнить инициализацию или очистку. Не передаются в DLL управляемых языков, так как они не имеют метода DllMain.

На самом деле ситуация с производительностью ещё хуже из-за необходимости _переключения контектса_ (context switching). Операционная система должна распределеять ресурсы физического процессора между виртуальными. В произвольный момент времени Windows передаёт процессору на исполнение один поток. Этот поток исполняется в течение некоторого временного интервала - _такта_ (quantum). После завершения интервала происходит переключение на другой поток. При этом обязательно происходит следующее:
1. Знапчения регистров процессора исполняющегося в данный момент потока сохраняются в структуре контекста, которая располагается в ядре потока.
2. Из набора потоков выделяется тот, которому будет передано управление. Если выбранный поток принадлежит другому процесу, Windows переключает для процессора виртуальное адресное пространство. Только после этого возможно выполнение кода или доступ к данным.
3. Значения выбранной структуры контекста потока загружаются в регистры процессора.

После переключения контекста процессор исполняет выбранный поток, пока не истечёт выделенное потоку время, после чего снова проиходит переключение. Windows делает это примерно каждые 30 мс. Никакого выигрыша в производительности или потреблении памяти это не даёт, это требуется для повышения отказоустойчивости, чтобы система могла реагировать на действия конечного пользователя.

Однако, ситуация с производительностью ещё хуже, так как при работе с одним потоком, его код и данные находятся в кэше процессора. При смене потоков процессор вынужден обратиться к оеративной памяти, чтобы наполнить кэш.

Иногда в конце такта Windows может продолжить исполнение уже исполняемого потока, при этом перключение контекста не переходит, а быстродейсствие повышается. Аналогично быстролдействие повышается, если поток уступает управление до завершения такта, например, засыпая в ожидании ввода-вывода.

В ходе сборки мусора CLR приостанавливает все потоки. Таким образом, сокращение количества потоков повысит производительность сборки мусора. Аналогично происходит с отладкой, так как все потоки также останавливаются.

## Так дальше не пойдёт!

Разработчики Windows отдали предпочтение надёжности, поэтому многие приложения создают потоки, вместо процессов, так как создание процессов - дорогостоящая процедура. Однако в результате создаётся множество простаивающих потоков.

## Тенденция развития процессоров

Существует три вида многопроцессорных технологий:
- **Многопроцессорные решения.** Популярность сходит на нет из-за большого размера и высокой стоимости.
- **Гиперпотоковые микросхемы.** Технология Intel, которая позволяет одной микросхеме функционировать как две. Для ОС это выглядит как наличие двух процессоров, и она одновременно планирует поведение двух потоков, выполняя только один из них.
- **Многоядерные микросхемы.** 

## CLR- и Windows-потоки

CLR-потоки аналогичны потокам Windows. 

## Потоки для асинхронных вычислительных операций



## Причины использования потоков



## Планирование и приоритеты потоков



## Фоновые и активные потоки



## Что дальше?

